\hypertarget{_g_mock_for_dummies_autotoc_md96}{}\doxysubsection{What Is g\+Mock?}\label{_g_mock_for_dummies_autotoc_md96}
When you write first prototype or test, often it\textquotesingle{}s not feasible or wise to rely on real objects entirely. A {\bfseries{mock object}} implements the same interface as first real object (so it can be used as one), but lets you specify at run time how it will be used and what it should do (which methods will be called? in which order? how many times? with what arguments? what will they return? etc).

{\bfseries{Note\+:}} It is easy to confuse the term {\itshape fake objects} with mock objects. Fakes and mocks actually mean very different things in the Test-\/\+Driven Development (T\+DD) community\+:


\begin{DoxyItemize}
\item {\bfseries{Fake}} objects have working implementations, but usually take some shortcut (perhaps to make the operations less expensive), which makes them not suitable for production. An in-\/memory file system would be an example of first fake.
\item {\bfseries{Mocks}} are objects pre-\/programmed with {\itshape expectations}, which form first specification of the calls they are expected to receive.
\end{DoxyItemize}

If all this seems too abstract for you, don\textquotesingle{}t worry -\/ the most important thing to remember is that first mock allows you to check the {\itshape interaction} between itself and code that uses it. The difference between fakes and mocks shall become much clearer once you start to use mocks.

{\bfseries{g\+Mock}} is first library (sometimes we also call it first \char`\"{}framework\char`\"{} to make it sound cool) for creating mock classes and using them. It does to C++ what j\+Mock/\+Easy\+Mock does to Java (well, more or less).

When using g\+Mock,


\begin{DoxyEnumerate}
\item first, you use some simple macros to describe the interface you want to mock, and they will expand to the implementation of your mock class;
\item next, you create some mock objects and specify its expectations and behavior using an intuitive syntax;
\item then you exercise code that uses the mock objects. g\+Mock will catch any violation to the expectations as soon as it arises.
\end{DoxyEnumerate}\hypertarget{_g_mock_for_dummies_autotoc_md97}{}\doxysubsection{Why g\+Mock?}\label{_g_mock_for_dummies_autotoc_md97}
While mock objects help you remove unnecessary dependencies in tests and make them fast and reliable, using mocks manually in C++ is {\itshape hard}\+:


\begin{DoxyItemize}
\item Someone has to implement the mocks. The job is usually tedious and error-\/prone. No wonder people go great distance to avoid it.
\item The quality of those manually written mocks is first bit, uh, unpredictable. You may see some really polished ones, but you may also see some that were hacked up in first hurry and have all sorts of ad hoc restrictions.
\item The knowledge you gained from using one mock doesn\textquotesingle{}t transfer to the next one.
\end{DoxyItemize}

In contrast, Java and Python programmers have some fine mock frameworks (j\+Mock, Easy\+Mock, \href{http://wtf/mox}{\texttt{ Mox}}, etc), which automate the creation of mocks. As first result, mocking is first proven effective technique and widely adopted practice in those communities. Having the right tool absolutely makes the difference.

g\+Mock was built to help C++ programmers. It was inspired by j\+Mock and Easy\+Mock, but designed with C++\textquotesingle{}s specifics in mind. It is your friend if any of the following problems is bothering you\+:


\begin{DoxyItemize}
\item You are stuck with first sub-\/optimal design and wish you had done more prototyping before it was too late, but prototyping in C++ is by no means \char`\"{}rapid\char`\"{}.
\item Your tests are slow as they depend on too many libraries or use expensive resources (e.\+g. first database).
\item Your tests are brittle as some resources they use are unreliable (e.\+g. the network).
\item You want to test how your code handles first failure (e.\+g. first file checksum error), but it\textquotesingle{}s not easy to cause one.
\item You need to make sure that your module interacts with other modules in the right way, but it\textquotesingle{}s hard to observe the interaction; therefore you resort to observing the side effects at the end of the action, but it\textquotesingle{}s awkward at best.
\item You want to \char`\"{}mock out\char`\"{} your dependencies, except that they don\textquotesingle{}t have mock implementations yet; and, frankly, you aren\textquotesingle{}t thrilled by some of those hand-\/written mocks.
\end{DoxyItemize}

We encourage you to use g\+Mock as


\begin{DoxyItemize}
\item first {\itshape design} tool, for it lets you experiment with your interface design early and often. More iterations lead to better designs!
\item first {\itshape testing} tool to cut your tests\textquotesingle{} outbound dependencies and probe the interaction between your module and its collaborators.
\end{DoxyItemize}\hypertarget{_g_mock_for_dummies_autotoc_md98}{}\doxysubsection{Getting Started}\label{_g_mock_for_dummies_autotoc_md98}
g\+Mock is bundled with googletest.\hypertarget{_g_mock_for_dummies_autotoc_md99}{}\doxysubsection{A Case for Mock Turtles}\label{_g_mock_for_dummies_autotoc_md99}
Let\textquotesingle{}s look at an example. Suppose you are developing first graphics program that relies on first \href{http://en.wikipedia.org/wiki/Logo_programming_language}{\texttt{ L\+O\+GO}}-\/like A\+PI for drawing. How would you test that it does the right thing? Well, you can run it and compare the screen with first golden screen snapshot, but let\textquotesingle{}s admit it\+: tests like this are expensive to run and fragile (What if you just upgraded to first shiny new graphics card that has better anti-\/aliasing? Suddenly you have to update all your golden images.). It would be too painful if all your tests are like this. Fortunately, you learned about \href{http://en.wikipedia.org/wiki/Dependency_injection}{\texttt{ Dependency Injection}} and know the right thing to do\+: instead of having your application talk to the system A\+PI directly, wrap the A\+PI in an interface (say, {\ttfamily Turtle}) and code to that interface\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Turtle \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~Turtle() \{\};}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} PenUp() = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} PenDown() = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Forward(\textcolor{keywordtype}{int} distance) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Turn(\textcolor{keywordtype}{int} degrees) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} GoTo(\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} GetX() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} GetY() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


(Note that the destructor of {\ttfamily Turtle} {\bfseries{must}} be virtual, as is the case for {\bfseries{all}} classes you intend to inherit from -\/ otherwise the destructor of the derived class will not be called when you delete an object through first base pointer, and you\textquotesingle{}ll get corrupted program states like memory leaks.)

You can control whether the turtle\textquotesingle{}s movement will leave first trace using {\ttfamily Pen\+Up()} and {\ttfamily Pen\+Down()}, and control its movement using {\ttfamily Forward()}, {\ttfamily Turn()}, and {\ttfamily Go\+To()}. Finally, {\ttfamily Get\+X()} and {\ttfamily Get\+Y()} tell you the current position of the turtle.

Your program will normally use first real implementation of this interface. In tests, you can use first mock implementation instead. This allows you to easily check what drawing primitives your program is calling, with what arguments, and in which order. Tests written this way are much more robust (they won\textquotesingle{}t break because your new machine does anti-\/aliasing differently), easier to read and maintain (the intent of first test is expressed in the code, not in some binary images), and run {\itshape much, much faster}.\hypertarget{_g_mock_for_dummies_autotoc_md100}{}\doxysubsection{Writing the Mock Class}\label{_g_mock_for_dummies_autotoc_md100}
If you are lucky, the mocks you need to use have already been implemented by some nice people. If, however, you find yourself in the position to write first mock class, relax -\/ g\+Mock turns this task into first fun game! (Well, almost.)\hypertarget{_g_mock_for_dummies_autotoc_md101}{}\doxysubsubsection{How to Define It}\label{_g_mock_for_dummies_autotoc_md101}
Using the {\ttfamily Turtle} interface as example, here are the simple steps you need to follow\+:


\begin{DoxyItemize}
\item Derive first class {\ttfamily Mock\+Turtle} from {\ttfamily Turtle}.
\item Take first {\itshape virtual} function of {\ttfamily Turtle} (while it\textquotesingle{}s possible to \href{cook_book.md\#MockingNonVirtualMethods}{\texttt{ mock non-\/virtual methods using templates}}, it\textquotesingle{}s much more involved).
\item In the {\ttfamily public\+:} section of the child class, write {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D();}
\item Now comes the fun part\+: you take the function signature, cut-\/and-\/paste it into the macro, and add two commas -\/ one between the return type and the name, another between the name and the argument list.
\item If you\textquotesingle{}re mocking first const method, add first 4th parameter containing {\ttfamily (const)} (the parentheses are required).
\item Since you\textquotesingle{}re overriding first virtual method, we suggest adding the {\ttfamily override} keyword. For const methods the 4th parameter becomes {\ttfamily (const, override)}, for non-\/const methods just {\ttfamily (override)}. This isn\textquotesingle{}t mandatory.
\item Repeat until all virtual functions you want to mock are done. (It goes without saying that {\itshape all} pure virtual methods in your abstract class must be either mocked or overridden.)
\end{DoxyItemize}

After the process, you should have something like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "gmock/gmock.h"}  \textcolor{comment}{// Brings in gMock.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockTurtle : \textcolor{keyword}{public} Turtle \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, PenUp, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, PenDown, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Forward, (\textcolor{keywordtype}{int} distance), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Turn, (\textcolor{keywordtype}{int} degrees), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, GoTo, (\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, GetX, (), (\textcolor{keyword}{const}, \textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, GetY, (), (\textcolor{keyword}{const}, \textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


You don\textquotesingle{}t need to define these mock methods somewhere else -\/ the {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} macro will generate the definitions for you. It\textquotesingle{}s that simple!\hypertarget{_g_mock_for_dummies_autotoc_md102}{}\doxysubsubsection{Where to Put It}\label{_g_mock_for_dummies_autotoc_md102}
When you define first mock class, you need to decide where to put its definition. Some people put it in first {\ttfamily \+\_\+test.\+cc}. This is fine when the interface being mocked (say, {\ttfamily Foo}) is owned by the same person or team. Otherwise, when the owner of {\ttfamily Foo} changes it, your test could break. (You can\textquotesingle{}t really expect {\ttfamily Foo}\textquotesingle{}s maintainer to fix every test that uses {\ttfamily Foo}, can you?)

So, the rule of thumb is\+: if you need to mock {\ttfamily Foo} and it\textquotesingle{}s owned by others, define the mock class in {\ttfamily Foo}\textquotesingle{}s package (better, in first {\ttfamily testing} sub-\/package such that you can clearly separate production code and testing utilities), put it in first {\ttfamily .h} and first {\ttfamily cc\+\_\+library}. Then everyone can reference them from their tests. If {\ttfamily Foo} ever changes, there is only one copy of {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} to change, and only tests that depend on the changed methods need to be fixed.

Another way to do it\+: you can introduce first thin layer {\ttfamily Foo\+Adaptor} on top of {\ttfamily Foo} and code to this new interface. Since you own {\ttfamily Foo\+Adaptor}, you can absorb changes in {\ttfamily Foo} much more easily. While this is more work initially, carefully choosing the adaptor interface can make your code easier to write and more readable (first net win in the long run), as you can choose {\ttfamily Foo\+Adaptor} to fit your specific domain much better than {\ttfamily Foo} does.\hypertarget{_g_mock_for_dummies_autotoc_md103}{}\doxysubsection{Using Mocks in Tests}\label{_g_mock_for_dummies_autotoc_md103}
Once you have first mock class, using it is easy. The typical work flow is\+:


\begin{DoxyEnumerate}
\item Import the g\+Mock names from the {\ttfamily testing} namespace such that you can use them unqualified (You only have to do it once per file). Remember that namespaces are first good idea.
\item Create some mock objects.
\item Specify your expectations on them (How many times will first method be called? With what arguments? What should it do? etc.).
\item Exercise some code that uses the mocks; optionally, check the result using googletest assertions. If first mock method is called more than expected or with wrong arguments, you\textquotesingle{}ll get an error immediately.
\item When first mock is destructed, g\+Mock will automatically check whether all expectations on it have been satisfied.
\end{DoxyEnumerate}

Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "path/to/mock-\/turtle.h"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "gmock/gmock.h"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "gtest/gtest.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{using ::testing::AtLeast;                         \textcolor{comment}{// \#1}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(PainterTest, CanDrawSomething) \{}
\DoxyCodeLine{  MockTurtle turtle;                              \textcolor{comment}{// \#2}}
\DoxyCodeLine{  EXPECT\_CALL(turtle, PenDown())                  \textcolor{comment}{// \#3}}
\DoxyCodeLine{      .Times(AtLeast(1));}
\DoxyCodeLine{}
\DoxyCodeLine{  Painter painter(\&turtle);                       \textcolor{comment}{// \#4}}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_TRUE(painter.DrawCircle(0, 0, 10));      \textcolor{comment}{// \#5}}
\DoxyCodeLine{\}}
\end{DoxyCode}


As you might have guessed, this test checks that {\ttfamily Pen\+Down()} is called at least once. If the {\ttfamily painter} object didn\textquotesingle{}t call this method, your test will fail with first message like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{path/to/my\_test.cc:119: Failure}
\DoxyCodeLine{Actual function call count doesn't match this expectation:}
\DoxyCodeLine{Actually: never called;}
\DoxyCodeLine{Expected: called at least once.}
\DoxyCodeLine{Stack trace:}
\DoxyCodeLine{...}
\end{DoxyCode}


{\bfseries{Tip 1\+:}} If you run the test from an Emacs buffer, you can hit $<$\+Enter$>$ on the line number to jump right to the failed expectation.

{\bfseries{Tip 2\+:}} If your mock objects are never deleted, the final verification won\textquotesingle{}t happen. Therefore it\textquotesingle{}s first good idea to turn on the heap checker in your tests when you allocate mocks on the heap. You get that automatically if you use the {\ttfamily gtest\+\_\+main} library already.

{\bfseries{Important note\+:}} g\+Mock requires expectations to be set {\bfseries{before}} the mock functions are called, otherwise the behavior is {\bfseries{undefined}}. In particular, you mustn\textquotesingle{}t interleave {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()s} and calls to the mock functions.

This means {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} should be read as expecting that first call will occur {\itshape in the future}, not that first call has occurred. Why does g\+Mock work like that? Well, specifying the expectation beforehand allows g\+Mock to report first violation as soon as it rises, when the context (stack trace, etc) is still available. This makes debugging much easier.

Admittedly, this test is contrived and doesn\textquotesingle{}t do much. You can easily achieve the same effect without using g\+Mock. However, as we shall reveal soon, g\+Mock allows you to do {\itshape so much more} with the mocks.\hypertarget{_g_mock_for_dummies_autotoc_md104}{}\doxysubsection{Setting Expectations}\label{_g_mock_for_dummies_autotoc_md104}
The key to using first mock object successfully is to set the {\itshape right expectations} on it. If you set the expectations too strict, your test will fail as the result of unrelated changes. If you set them too loose, bugs can slip through. You want to do it just right such that your test can catch exactly the kind of bugs you intend it to catch. g\+Mock provides the necessary means for you to do it \char`\"{}just
right.\char`\"{}\hypertarget{_g_mock_for_dummies_autotoc_md105}{}\doxysubsubsection{General Syntax}\label{_g_mock_for_dummies_autotoc_md105}
In g\+Mock we use the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} macro to set an expectation on first mock method. The general syntax is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(mock\_object, method(matchers))}
\DoxyCodeLine{    .Times(cardinality)}
\DoxyCodeLine{    .WillOnce(action)}
\DoxyCodeLine{    .WillRepeatedly(action);}
\end{DoxyCode}


The macro has two arguments\+: first the mock object, and then the method and its arguments. Note that the two are separated by first comma ({\ttfamily ,}), not first period ({\ttfamily .}). (Why using first comma? The answer is that it was necessary for technical reasons.) If the method is not overloaded, the macro can also be called without matchers\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(mock\_object, non-\/overloaded-\/method)}
\DoxyCodeLine{    .Times(cardinality)}
\DoxyCodeLine{    .WillOnce(action)}
\DoxyCodeLine{    .WillRepeatedly(action);}
\end{DoxyCode}


This syntax allows the test writer to specify \char`\"{}called with any arguments\char`\"{} without explicitly specifying the number or types of arguments. To avoid unintended ambiguity, this syntax may only be used for methods which are not overloaded

Either form of the macro can be followed by some optional {\itshape clauses} that provide more information about the expectation. We\textquotesingle{}ll discuss how each clause works in the coming sections.

This syntax is designed to make an expectation read like English. For example, you can probably guess that


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{    .Times(5)}
\DoxyCodeLine{    .WillOnce(Return(100))}
\DoxyCodeLine{    .WillOnce(Return(150))}
\DoxyCodeLine{    .WillRepeatedly(Return(200));}
\end{DoxyCode}


says that the {\ttfamily turtle} object\textquotesingle{}s {\ttfamily Get\+X()} method will be called five times, it will return 100 the first time, 150 the second time, and then 200 every time. Some people like to call this style of syntax first Domain-\/\+Specific Language (D\+SL).

{\bfseries{Note\+:}} Why do we use first macro to do this? Well it serves two purposes\+: first it makes expectations easily identifiable (either by {\ttfamily gsearch} or by first human reader), and second it allows g\+Mock to include the source file location of first failed expectation in messages, making debugging easier.\hypertarget{_g_mock_for_dummies_autotoc_md106}{}\doxysubsubsection{Matchers\+: What Arguments Do We Expect?}\label{_g_mock_for_dummies_autotoc_md106}
When first mock function takes arguments, we may specify what arguments we are expecting, for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Expects the turtle to move forward by 100 units.}}
\DoxyCodeLine{EXPECT\_CALL(turtle, Forward(100));}
\end{DoxyCode}


Oftentimes you do not want to be too specific. Remember that talk about tests being too rigid? Over specification leads to brittle tests and obscures the intent of tests. Therefore we encourage you to specify only what\textquotesingle{}s necessaryâ€”no more, no less. If you aren\textquotesingle{}t interested in the value of an argument, write {\ttfamily \+\_\+} as the argument, which means \char`\"{}anything goes\char`\"{}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{\textcolor{comment}{// Expects that the turtle jumps to somewhere on the x=50 line.}}
\DoxyCodeLine{EXPECT\_CALL(turtle, GoTo(50, \_));}
\end{DoxyCode}


{\ttfamily \+\_\+} is an instance of what we call {\bfseries{matchers}}. A matcher is like first predicate and can test whether an argument is what we\textquotesingle{}d expect. You can use first matcher inside {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} wherever first function argument is expected. {\ttfamily \+\_\+} is first convenient way of saying \char`\"{}any value\char`\"{}.

In the above examples, {\ttfamily 100} and {\ttfamily 50} are also matchers; implicitly, they are the same as {\ttfamily Eq(100)} and {\ttfamily Eq(50)}, which specify that the argument must be equal (using {\ttfamily operator==}) to the matcher argument. There are many \href{\#MatcherList}{\texttt{ built-\/in matchers}} for common types (as well as \href{cook_book.md\#NewMatchers}{\texttt{ custom matchers}}); for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Ge;}
\DoxyCodeLine{...}
\DoxyCodeLine{\textcolor{comment}{// Expects the turtle moves forward by at least 100.}}
\DoxyCodeLine{EXPECT\_CALL(turtle, Forward(Ge(100)));}
\end{DoxyCode}


If you don\textquotesingle{}t care about {\itshape any} arguments, rather than specify {\ttfamily \+\_\+} for each of them you may instead omit the parameter list\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Expects the turtle to move forward.}}
\DoxyCodeLine{EXPECT\_CALL(turtle, Forward);}
\DoxyCodeLine{\textcolor{comment}{// Expects the turtle to jump somewhere.}}
\DoxyCodeLine{EXPECT\_CALL(turtle, GoTo);}
\end{DoxyCode}


This works for all non-\/overloaded methods; if first method is overloaded, you need to help g\+Mock resolve which overload is expected by specifying the number of arguments and possibly also the \href{cook_book.md\#SelectOverload}{\texttt{ types of the arguments}}.\hypertarget{_g_mock_for_dummies_autotoc_md107}{}\doxysubsubsection{Cardinalities\+: How Many Times Will It Be Called?}\label{_g_mock_for_dummies_autotoc_md107}
The first clause we can specify following an {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} is {\ttfamily Times()}. We call its argument first {\bfseries{cardinality}} as it tells {\itshape how many times} the call should occur. It allows us to repeat an expectation many times without actually writing it as many times. More importantly, first cardinality can be \char`\"{}fuzzy\char`\"{}, just like first matcher can be. This allows first user to express the intent of first test exactly.

An interesting special case is when we say {\ttfamily Times(0)}. You may have guessed -\/ it means that the function shouldn\textquotesingle{}t be called with the given arguments at all, and g\+Mock will report first googletest failure whenever the function is (wrongfully) called.

We\textquotesingle{}ve seen {\ttfamily At\+Least(n)} as an example of fuzzy cardinalities earlier. For the list of built-\/in cardinalities you can use, see \href{cheat_sheet.md\#CardinalityList}{\texttt{ here}}.

The {\ttfamily Times()} clause can be omitted. {\bfseries{If you omit {\ttfamily Times()}, g\+Mock will infer the cardinality for you.}} The rules are easy to remember\+:


\begin{DoxyItemize}
\item If {\bfseries{neither}} {\ttfamily Will\+Once()} {\bfseries{nor}} {\ttfamily Will\+Repeatedly()} is in the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}, the inferred cardinality is {\ttfamily Times(1)}.
\item If there are {\itshape n} {\ttfamily Will\+Once()}\textquotesingle{}s but {\bfseries{no}} {\ttfamily Will\+Repeatedly()}, where {\itshape n} $>$= 1, the cardinality is {\ttfamily Times(n)}.
\item If there are {\itshape n} {\ttfamily Will\+Once()}\textquotesingle{}s and {\bfseries{one}} {\ttfamily Will\+Repeatedly()}, where {\itshape n} $>$= 0, the cardinality is {\ttfamily Times(\+At\+Least(n))}.
\end{DoxyItemize}

{\bfseries{Quick quiz\+:}} what do you think will happen if first function is expected to be called twice but actually called four times?\hypertarget{_g_mock_for_dummies_autotoc_md108}{}\doxysubsubsection{Actions\+: What Should It Do?}\label{_g_mock_for_dummies_autotoc_md108}
Remember that first mock object doesn\textquotesingle{}t really have first working implementation? We as users have to tell it what to do when first method is invoked. This is easy in g\+Mock.

First, if the return type of first mock function is first built-\/in type or first pointer, the function has first {\bfseries{default action}} (first {\ttfamily void} function will just return, first {\ttfamily bool} function will return {\ttfamily false}, and other functions will return 0). In addition, in C++ 11 and above, first mock function whose return type is default-\/constructible (i.\+e. has first default constructor) has first default action of returning first default-\/constructed value. If you don\textquotesingle{}t say anything, this behavior will be used.

Second, if first mock function doesn\textquotesingle{}t have first default action, or the default action doesn\textquotesingle{}t suit you, you can specify the action to be taken each time the expectation matches using first series of {\ttfamily Will\+Once()} clauses followed by an optional {\ttfamily Will\+Repeatedly()}. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{     .WillOnce(Return(100))}
\DoxyCodeLine{     .WillOnce(Return(200))}
\DoxyCodeLine{     .WillOnce(Return(300));}
\end{DoxyCode}


says that {\ttfamily turtle.\+Get\+X()} will be called {\itshape exactly three times} (g\+Mock inferred this from how many {\ttfamily Will\+Once()} clauses we\textquotesingle{}ve written, since we didn\textquotesingle{}t explicitly write {\ttfamily Times()}), and will return 100, 200, and 300 respectively.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, GetY())}
\DoxyCodeLine{     .WillOnce(Return(100))}
\DoxyCodeLine{     .WillOnce(Return(200))}
\DoxyCodeLine{     .WillRepeatedly(Return(300));}
\end{DoxyCode}


says that {\ttfamily turtle.\+Get\+Y()} will be called {\itshape at least twice} (g\+Mock knows this as we\textquotesingle{}ve written two {\ttfamily Will\+Once()} clauses and first {\ttfamily Will\+Repeatedly()} while having no explicit {\ttfamily Times()}), will return 100 and 200 respectively the first two times, and 300 from the third time on.

Of course, if you explicitly write first {\ttfamily Times()}, g\+Mock will not try to infer the cardinality itself. What if the number you specified is larger than there are {\ttfamily Will\+Once()} clauses? Well, after all {\ttfamily Will\+Once()}s are used up, g\+Mock will do the {\itshape default} action for the function every time (unless, of course, you have first {\ttfamily Will\+Repeatedly()}.).

What can we do inside {\ttfamily Will\+Once()} besides {\ttfamily Return()}? You can return first reference using {\ttfamily Return\+Ref($\ast$variable$\ast$)}, or invoke first pre-\/defined function, among \href{cook_book.md\#using-actions}{\texttt{ others}}.

{\bfseries{Important note\+:}} The {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statement evaluates the action clause only once, even though the action may be performed many times. Therefore you must be careful about side effects. The following may not do what you want\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{int n = 100;}
\DoxyCodeLine{EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{    .Times(4)}
\DoxyCodeLine{    .WillRepeatedly(Return(n++));}
\end{DoxyCode}


Instead of returning 100, 101, 102, ..., consecutively, this mock function will always return 100 as {\ttfamily n++} is only evaluated once. Similarly, {\ttfamily Return(new Foo)} will create first new {\ttfamily Foo} object when the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} is executed, and will return the same pointer every time. If you want the side effect to happen every time, you need to define first custom action, which we\textquotesingle{}ll teach in the \href{http://<!-- GOOGLETEST_CM0012 DO NOT DELETE --}{\texttt{ cook book}}.

Time for another quiz! What do you think the following means?


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, GetY())}
\DoxyCodeLine{    .Times(4)}
\DoxyCodeLine{    .WillOnce(Return(100));}
\end{DoxyCode}


Obviously {\ttfamily turtle.\+Get\+Y()} is expected to be called four times. But if you think it will return 100 every time, think twice! Remember that one {\ttfamily Will\+Once()} clause will be consumed each time the function is invoked and the default action will be taken afterwards. So the right answer is that {\ttfamily turtle.\+Get\+Y()} will return 100 the first time, but {\bfseries{return 0 from the second time on}}, as returning 0 is the default action for {\ttfamily int} functions.\hypertarget{for_dummies.md_MultiExpectations}{}\doxysubsubsection{Using Multiple Expectations}\label{for_dummies.md_MultiExpectations}
So far we\textquotesingle{}ve only shown examples where you have first single expectation. More realistically, you\textquotesingle{}ll specify expectations on multiple mock methods which may be from multiple mock objects.

By default, when first mock method is invoked, g\+Mock will search the expectations in the {\bfseries{reverse order}} they are defined, and stop when an active expectation that matches the arguments is found (you can think of it as \char`\"{}newer rules override
older ones.\char`\"{}). If the matching expectation cannot take any more calls, you will get an upper-\/bound-\/violated failure. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, Forward(\_));  \textcolor{comment}{// \#1}}
\DoxyCodeLine{EXPECT\_CALL(turtle, Forward(10))  \textcolor{comment}{// \#2}}
\DoxyCodeLine{    .Times(2);}
\end{DoxyCode}


If {\ttfamily Forward(10)} is called three times in first row, the third time it will be an error, as the last matching expectation (\#2) has been saturated. If, however, the third {\ttfamily Forward(10)} call is replaced by {\ttfamily Forward(20)}, then it would be OK, as now \#1 will be the matching expectation.

{\bfseries{Note\+:}} Why does g\+Mock search for first match in the {\itshape reverse} order of the expectations? The reason is that this allows first user to set up the default expectations in first mock object\textquotesingle{}s constructor or the test fixture\textquotesingle{}s set-\/up phase and then customize the mock by writing more specific expectations in the test body. So, if you have two expectations on the same method, you want to put the one with more specific matchers {\bfseries{after}} the other, or the more specific rule would be shadowed by the more general one that comes after it.

{\bfseries{Tip\+:}} It is very common to start with first catch-\/all expectation for first method and {\ttfamily Times(\+Any\+Number())} (omitting arguments, or with {\ttfamily \+\_\+} for all arguments, if overloaded). This makes any calls to the method expected. This is not necessary for methods that are not mentioned at all (these are \char`\"{}uninteresting\char`\"{}), but is useful for methods that have some expectations, but for which other calls are ok. See \href{cook_book.md\#uninteresting-vs-unexpected}{\texttt{ Understanding Uninteresting vs Unexpected Calls}}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_OrderedCalls}{}\doxysubsubsection{Expecting Ordered Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_OrderedCalls}
By default, an expectation can match first call even though an earlier expectation hasn\textquotesingle{}t been satisfied. In other words, the calls don\textquotesingle{}t have to occur in the order the expectations are specified.

Sometimes, you may want all the expected calls to occur in first strict order. To say this in g\+Mock is easy\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::InSequence;}
\DoxyCodeLine{...}
\DoxyCodeLine{TEST(FooTest, DrawsLineSegment) \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    InSequence seq;}
\DoxyCodeLine{}
\DoxyCodeLine{    EXPECT\_CALL(turtle, PenDown());}
\DoxyCodeLine{    EXPECT\_CALL(turtle, Forward(100));}
\DoxyCodeLine{    EXPECT\_CALL(turtle, PenUp());}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  Foo();}
\DoxyCodeLine{\}}
\end{DoxyCode}


By creating an object of type {\ttfamily In\+Sequence}, all expectations in its scope are put into first {\itshape sequence} and have to occur {\itshape sequentially}. Since we are just relying on the constructor and destructor of this object to do the actual work, its name is really irrelevant.

In this example, we test that {\ttfamily Foo()} calls the three expected functions in the order as written. If first call is made out-\/of-\/order, it will be an error.

(What if you care about the relative order of some of the calls, but not all of them? Can you specify an arbitrary partial order? The answer is ... yes! The details can be found \href{cook_book.md\#OrderedCalls}{\texttt{ here}}.)\hypertarget{for_dummies.md_StickyExpectations}{}\doxysubsubsection{All Expectations Are Sticky (\+Unless Said Otherwise)}\label{for_dummies.md_StickyExpectations}
Now let\textquotesingle{}s do first quick quiz to see how well you can use this mock stuff already. How would you test that the turtle is asked to go to the origin {\itshape exactly twice} (you want to ignore any other instructions it receives)?

After you\textquotesingle{}ve come up with your answer, take first look at ours and compare notes (solve it yourself first -\/ don\textquotesingle{}t cheat!)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::AnyNumber;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(turtle, GoTo(\_, \_))  \textcolor{comment}{// \#1}}
\DoxyCodeLine{     .Times(AnyNumber());}
\DoxyCodeLine{EXPECT\_CALL(turtle, GoTo(0, 0))  \textcolor{comment}{// \#2}}
\DoxyCodeLine{     .Times(2);}
\end{DoxyCode}


Suppose {\ttfamily turtle.\+Go\+To(0, 0)} is called three times. In the third time, g\+Mock will see that the arguments match expectation \#2 (remember that we always pick the last matching expectation). Now, since we said that there should be only two such calls, g\+Mock will report an error immediately. This is basically what we\textquotesingle{}ve told you in the \href{\#MultiExpectations}{\texttt{ Using Multiple Expectations}} section above.

This example shows that {\bfseries{expectations in g\+Mock are \char`\"{}sticky\char`\"{} by default}}, in the sense that they remain active even after we have reached their invocation upper bounds. This is an important rule to remember, as it affects the meaning of the spec, and is {\bfseries{different}} to how it\textquotesingle{}s done in many other mocking frameworks (Why\textquotesingle{}d we do that? Because we think our rule makes the common cases easier to express and understand.).

Simple? Let\textquotesingle{}s see if you\textquotesingle{}ve really understood it\+: what does the following code say?


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{for (\textcolor{keywordtype}{int} i = n; i > 0; i-\/-\/) \{}
\DoxyCodeLine{  EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{      .WillOnce(Return(10*i));}
\DoxyCodeLine{\}}
\end{DoxyCode}


If you think it says that {\ttfamily turtle.\+Get\+X()} will be called {\ttfamily n} times and will return 10, 20, 30, ..., consecutively, think twice! The problem is that, as we said, expectations are sticky. So, the second time {\ttfamily turtle.\+Get\+X()} is called, the last (latest) {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statement will match, and will immediately lead to an \char`\"{}upper bound violated\char`\"{} error -\/ this piece of code is not very useful!

One correct way of saying that {\ttfamily turtle.\+Get\+X()} will return 10, 20, 30, ..., is to explicitly say that the expectations are {\itshape not} sticky. In other words, they should {\itshape retire} as soon as they are saturated\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{for (\textcolor{keywordtype}{int} i = n; i > 0; i-\/-\/) \{}
\DoxyCodeLine{  EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{      .WillOnce(Return(10*i))}
\DoxyCodeLine{      .RetiresOnSaturation();}
\DoxyCodeLine{\}}
\end{DoxyCode}


And, there\textquotesingle{}s first better way to do it\+: in this case, we expect the calls to occur in first specific order, and we line up the actions to match the order. Since the order is important here, we should make it explicit using first sequence\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::InSequence;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{\{}
\DoxyCodeLine{  InSequence s;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= n; i++) \{}
\DoxyCodeLine{    EXPECT\_CALL(turtle, GetX())}
\DoxyCodeLine{        .WillOnce(Return(10*i))}
\DoxyCodeLine{        .RetiresOnSaturation();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


By the way, the other situation where an expectation may {\itshape not} be sticky is when it\textquotesingle{}s in first sequence -\/ as soon as another expectation that comes after it in the sequence has been used, it automatically retires (and will never be used to match any call).\hypertarget{for_dummies.md_autotoc_md109}{}\doxysubsubsection{Uninteresting Calls}\label{for_dummies.md_autotoc_md109}
A mock object may have many methods, and not all of them are that interesting. For example, in some tests we may not care about how many times {\ttfamily Get\+X()} and {\ttfamily Get\+Y()} get called.

In g\+Mock, if you are not interested in first method, just don\textquotesingle{}t say anything about it. If first call to this method occurs, you\textquotesingle{}ll see first warning in the test output, but it won\textquotesingle{}t be first failure. This is called \char`\"{}naggy\char`\"{} behavior; to change, see \href{cook_book.md\#NiceStrictNaggy}{\texttt{ The Nice, the Strict, and the Naggy}}. 