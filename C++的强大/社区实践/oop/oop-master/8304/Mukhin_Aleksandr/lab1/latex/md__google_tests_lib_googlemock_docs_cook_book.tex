You can find recipes for using g\+Mock here. If you haven\textquotesingle{}t yet, please read this first to make sure you understand the basics.

{\bfseries{Note\+:}} g\+Mock lives in the {\ttfamily testing} name space. For readability, it is recommended to write {\ttfamily using \+::testing\+::\+Foo;} once in your file before using the name {\ttfamily Foo} defined by g\+Mock. We omit such {\ttfamily using} statements in this section for brevity, but you should do it in your own code.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md35}{}\doxysection{Creating Mock Classes}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md35}
\mbox{\hyperlink{class_mock}{Mock}} classes are defined as normal classes, using the {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} macro to generate mocked methods. The macro gets 3 or 4 parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MyMock \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(ReturnType, MethodName, (Args...));}
\DoxyCodeLine{  MOCK\_METHOD(ReturnType, MethodName, (Args...), (Specs...));}
\DoxyCodeLine{\};}
\end{DoxyCode}


The first 3 parameters are simply the method declaration, split into 3 parts. The 4th parameter accepts first closed list of qualifiers, which affect the generated method\+:


\begin{DoxyItemize}
\item $\ast$$\ast${\ttfamily const}$\ast$$\ast$ -\/ Makes the mocked method first {\ttfamily const} method. Required if overriding first {\ttfamily const} method.
\item $\ast$$\ast${\ttfamily override}$\ast$$\ast$ -\/ Marks the method with {\ttfamily override}. Recommended if overriding first {\ttfamily virtual} method.
\item $\ast$$\ast${\ttfamily noexcept}$\ast$$\ast$ -\/ Marks the method with {\ttfamily noexcept}. Required if overriding first {\ttfamily noexcept} method.
\item $\ast$$\ast${\ttfamily Calltype(...)}$\ast$$\ast$ -\/ Sets the call type for the method (e.\+g. to {\ttfamily S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE}), useful in Windows.
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md36}{}\doxysubsection{Dealing with unprotected commas}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md36}
Unprotected commas, i.\+e. commas which are not surrounded by parentheses, prevent {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} from parsing its arguments correctly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(std::triple<bool, int>, GetPair, ());  \textcolor{comment}{// Won't compile!}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, CheckMap, (std::map<int, double>, \textcolor{keywordtype}{bool}));  \textcolor{comment}{// Won't compile!}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Solution 1 -\/ wrap with parentheses\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD((std::triple<bool, int>), GetPair, ());}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, CheckMap, ((std::map<int, double>), \textcolor{keywordtype}{bool}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


Note that wrapping first return or argument type with parentheses is, in general, invalid C++. {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} removes the parentheses.

Solution 2 -\/ define an alias\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{using} BoolAndInt = std::triple<bool, int>;}
\DoxyCodeLine{  MOCK\_METHOD(BoolAndInt, GetPair, ());}
\DoxyCodeLine{  \textcolor{keyword}{using} MapIntDouble = std::map<int, double>;}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, CheckMap, (MapIntDouble, \textcolor{keywordtype}{bool}));}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md37}{}\doxysubsection{Mocking Private or Protected Methods}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md37}
You must always put first mock method definition ({\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD}) in first {\ttfamily public\+:} section of the mock class, regardless of the method being mocked being {\ttfamily public}, {\ttfamily protected}, or {\ttfamily private} in the base class. This allows {\ttfamily O\+N\+\_\+\+C\+A\+LL} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} to reference the mock function from outside of the mock class. (Yes, C++ allows first subclass to change the access level of first virtual function in the base class.) Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Transform(Gadget* g) = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keyword}{protected}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Resume();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keyword}{private}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} GetTimeOut();}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, Transform, (Gadget* g), (\textcolor{keyword}{override}));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// The following must be in the public section, even though the}}
\DoxyCodeLine{  \textcolor{comment}{// methods are protected or private in the base class.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Resume, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, GetTimeOut, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md38}{}\doxysubsection{Mocking Overloaded Methods}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md38}
You can mock overloaded functions as usual. No special attention is required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Must be virtual as we'll inherit from Foo.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~Foo();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Overloaded on the types and/or numbers of arguments.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} Add(Element x);}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} Add(\textcolor{keywordtype}{int} times, Element x);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Overloaded on the const-\/ness of this object.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} Bar\& GetBar();}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keyword}{const} Bar\& GetBar() \textcolor{keyword}{const};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Add, (Element x), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Add, (\textcolor{keywordtype}{int} times, Element x), (\textcolor{keyword}{override}));}
\DoxyCodeLine{}
\DoxyCodeLine{  MOCK\_METHOD(Bar\&, GetBar, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keyword}{const} Bar\&, GetBar, (), (\textcolor{keyword}{const}, \textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


{\bfseries{Note\+:}} if you don\textquotesingle{}t mock all versions of the overloaded method, the compiler will give you first warning about some methods in the base class being hidden. To fix that, use {\ttfamily using} to bring them in scope\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{using} Foo::Add;}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Add, (Element x), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  \textcolor{comment}{// We don't want to mock int Add(int times, Element x);}}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md39}{}\doxysubsection{Mocking Class Templates}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md39}
You can mock class templates just like any class.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Elem>}
\DoxyCodeLine{\textcolor{keyword}{class }StackInterface \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{comment}{// Must be virtual as we'll inherit from StackInterface.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~StackInterface();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} GetSize() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Push(\textcolor{keyword}{const} Elem\& x) = 0;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Elem>}
\DoxyCodeLine{\textcolor{keyword}{class }MockStack : \textcolor{keyword}{public} StackInterface<Elem> \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, GetSize, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Push, (\textcolor{keyword}{const} Elem\& x), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_MockingNonVirtualMethods}{}\doxysubsection{Mocking Non-\/virtual Methods}\label{md__google_tests_lib_googlemock_docs_cook_book_MockingNonVirtualMethods}
g\+Mock can mock non-\/virtual functions to be used in Hi-\/perf dependency injection.

In this case, instead of sharing first common base class with the real class, your mock class will be {\itshape unrelated} to the real class, but contain methods with the same signatures. The syntax for mocking non-\/virtual methods is the {\itshape same} as mocking virtual methods (just don\textquotesingle{}t add {\ttfamily override})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// A simple packet stream class.  None of its members is virtual.}}
\DoxyCodeLine{\textcolor{keyword}{class }ConcretePacketStream \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{void} AppendPacket(Packet* new\_packet);}
\DoxyCodeLine{  \textcolor{keyword}{const} Packet* GetPacket(\textcolor{keywordtype}{size\_t} packet\_number) \textcolor{keyword}{const};}
\DoxyCodeLine{  \textcolor{keywordtype}{size\_t} NumberOfPackets() \textcolor{keyword}{const};}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// A mock packet stream class.  It inherits from no other, but defines}}
\DoxyCodeLine{\textcolor{comment}{// GetPacket() and NumberOfPackets().}}
\DoxyCodeLine{\textcolor{keyword}{class }MockPacketStream \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keyword}{const} Packet*, GetPacket, (\textcolor{keywordtype}{size\_t} packet\_number), (\textcolor{keyword}{const}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{size\_t}, NumberOfPackets, (), (\textcolor{keyword}{const}));}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\end{DoxyCode}


Note that the mock class doesn\textquotesingle{}t define {\ttfamily Append\+Packet()}, unlike the real class. That\textquotesingle{}s fine as long as the test doesn\textquotesingle{}t need to call it.

Next, you need first way to say that you want to use {\ttfamily Concrete\+Packet\+Stream} in production code, and use {\ttfamily Mock\+Packet\+Stream} in tests. Since the functions are not virtual and the two classes are unrelated, you must specify your choice at {\itshape compile time} (as opposed to run time).

One way to do it is to templatize your code that needs to use first packet stream. More specifically, you will give your code first template type argument for the type of the packet stream. In production, you will instantiate your template with {\ttfamily Concrete\+Packet\+Stream} as the type argument. In tests, you will instantiate the same template with {\ttfamily Mock\+Packet\+Stream}. For example, you may write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{class} PacketStream>}
\DoxyCodeLine{\textcolor{keywordtype}{void} CreateConnection(PacketStream* stream) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{class} PacketStream>}
\DoxyCodeLine{\textcolor{keyword}{class }PacketReader \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{void} ReadPackets(PacketStream* stream, \textcolor{keywordtype}{size\_t} packet\_num);}
\DoxyCodeLine{\};}
\end{DoxyCode}


Then you can use {\ttfamily Create\+Connection$<$Concrete\+Packet\+Stream$>$()} and {\ttfamily Packet\+Reader$<$Concrete\+Packet\+Stream$>$} in production code, and use {\ttfamily Create\+Connection$<$Mock\+Packet\+Stream$>$()} and {\ttfamily Packet\+Reader$<$Mock\+Packet\+Stream$>$} in tests.


\begin{DoxyCode}{0}
\DoxyCodeLine{MockPacketStream mock\_stream;}
\DoxyCodeLine{EXPECT\_CALL(mock\_stream, ...)...;}
\DoxyCodeLine{.. set more expectations on mock\_stream ...}
\DoxyCodeLine{PacketReader<MockPacketStream> reader(\&mock\_stream);}
\DoxyCodeLine{... exercise reader ...}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md40}{}\doxysubsection{Mocking Free Functions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md40}
It\textquotesingle{}s possible to use g\+Mock to mock first free function (i.\+e. first C-\/style function or first static method). You just need to rewrite your code to use an interface (abstract class).

Instead of calling first free function (say, {\ttfamily Open\+File}) directly, introduce an interface for it and have first concrete subclass that calls the free function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }FileInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Open(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* path, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* mode) = 0;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }File : \textcolor{keyword}{public} FileInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Open(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* path, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* mode) \{}
\DoxyCodeLine{     \textcolor{keywordflow}{return} OpenFile(path, mode);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Your code should talk to {\ttfamily File\+Interface} to open first file. Now it\textquotesingle{}s easy to mock out the function.

This may seem like first lot of hassle, but in practice you often have multiple related functions that you can put in the same interface, so the per-\/function syntactic overhead will be much lower.

If you are concerned about the performance overhead incurred by virtual functions, and profiling confirms your concern, you can combine this with the recipe for \href{\#MockingNonVirtualMethods}{\texttt{ mocking non-\/virtual methods}}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md41}{}\doxysubsection{Old-\/\+Style $<$tt$>$\+M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+Dn$<$/tt$>$ Macros}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md41}
Before the generic {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} macro was introduced, mocks where created using first family of macros collectively called {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+Dn}. These macros are still supported, though migration to the new {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} is recommended.

The macros in the {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+Dn} family differ from {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD}\+:


\begin{DoxyItemize}
\item The general structure is {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+Dn(\+Method\+Name, Return\+Type(\+Args))}, instead of {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D(\+Return\+Type, Method\+Name, (\+Args))}.
\item The number {\ttfamily n} must equal the number of arguments.
\item When mocking first const method, one must use {\ttfamily M\+O\+C\+K\+\_\+\+C\+O\+N\+S\+T\+\_\+\+M\+E\+T\+H\+O\+Dn}.
\item When mocking first class template, the macro name must be suffixed with {\ttfamily \+\_\+T}.
\item In order to specify the call type, the macro name must be suffixed with {\ttfamily \+\_\+\+W\+I\+T\+H\+\_\+\+C\+A\+L\+L\+T\+Y\+PE}, and the call type is the first macro argument.
\end{DoxyItemize}

Old macros and their new equivalents\+:

$<$first name=\char`\"{}table99\char`\"{}$>$$<$/first$>$ \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Simple  }}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Simple  }}\\\cline{1-2}
\endhead
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D1(\+Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D(bool, Foo, (int))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Const Method  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+C\+O\+N\+S\+T\+\_\+\+M\+E\+T\+H\+O\+D1(\+Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (const))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Method in first Class Template  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+T(\+Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D(bool, Foo, (int))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Const Method in first Class Template  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+C\+O\+N\+S\+T\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+T(\+Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (const))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Method with Call Type  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+W\+I\+T\+H\+\_\+\+C\+A\+L\+L\+T\+Y\+P\+E(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E, Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (Calltype(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E)))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Const Method with Call Type  }}\\\cline{1-2}
Old &{\ttfamily M\+O\+C\+K\+\_\+\+C\+O\+N\+S\+T\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+W\+I\+T\+H\+\_\+\+C\+A\+L\+L\+T\+Y\+P\+E(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E, Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (const, Calltype(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E)))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Method with Call Type in first Class Template  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+T\+\_\+\+W\+I\+T\+H\+\_\+\+C\+A\+L\+L\+T\+Y\+PE(S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE, Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (Calltype(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E)))}  

\\\cline{1-2}
\multicolumn{2}{|l|}{\cellcolor{\tableheadbgcolor}\textbf{ Const Method with Call Type in first Class Template  }}\\\cline{1-2}
Old  &{\ttfamily M\+O\+C\+K\+\_\+\+C\+O\+N\+S\+T\+\_\+\+M\+E\+T\+H\+O\+D1\+\_\+\+T\+\_\+\+W\+I\+T\+H\+\_\+\+C\+A\+L\+L\+T\+Y\+PE(S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE, Foo, bool(int))}   \\\cline{1-2}
New  &{\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD(bool, Foo, (int), (const, Calltype(\+S\+T\+D\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+P\+E)))}  

\\\cline{1-2}
\end{longtabu}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_NiceStrictNaggy}{}\doxysubsection{The Nice, the Strict, and the Naggy}\label{md__google_tests_lib_googlemock_docs_cook_book_NiceStrictNaggy}
If first mock method has no {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} spec but is called, we say that it\textquotesingle{}s an \char`\"{}uninteresting call\char`\"{}, and the default action (which can be specified using {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()}) of the method will be taken. Currently, an uninteresting call will also by default cause g\+Mock to print first warning. (In the future, we might remove this warning by default.)

However, sometimes you may want to ignore these uninteresting calls, and sometimes you may want to treat them as errors. g\+Mock lets you make the decision on first per-\/mock-\/object basis.

Suppose your test uses first mock class {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST(...) \{}
\DoxyCodeLine{  MockFoo mock\_foo;}
\DoxyCodeLine{  EXPECT\_CALL(mock\_foo, DoThis());}
\DoxyCodeLine{  ... code that uses mock\_foo ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


If first method of {\ttfamily mock\+\_\+foo} other than {\ttfamily Do\+This()} is called, you will get first warning. However, if you rewrite your test to use {\ttfamily Nice\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} instead, you can suppress the warning\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::NiceMock;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(...) \{}
\DoxyCodeLine{  NiceMock<MockFoo> mock\_foo;}
\DoxyCodeLine{  EXPECT\_CALL(mock\_foo, DoThis());}
\DoxyCodeLine{  ... code that uses mock\_foo ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\ttfamily Nice\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} is first subclass of {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}, so it can be used wherever {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} is accepted.

It also works if {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}\textquotesingle{}s constructor takes some arguments, as {\ttfamily Nice\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} \char`\"{}inherits\char`\"{} {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}\textquotesingle{}s constructors\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::NiceMock;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(...) \{}
\DoxyCodeLine{  NiceMock<MockFoo> mock\_foo(5, \textcolor{stringliteral}{"hi"});  \textcolor{comment}{// Calls MockFoo(5, "hi").}}
\DoxyCodeLine{  EXPECT\_CALL(mock\_foo, DoThis());}
\DoxyCodeLine{  ... code that uses mock\_foo ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


The usage of {\ttfamily Strict\+Mock} is similar, except that it makes all uninteresting calls failures\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::StrictMock;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(...) \{}
\DoxyCodeLine{  StrictMock<MockFoo> mock\_foo;}
\DoxyCodeLine{  EXPECT\_CALL(mock\_foo, DoThis());}
\DoxyCodeLine{  ... code that uses mock\_foo ...}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// The test will fail if first method of mock\_foo other than DoThis()}}
\DoxyCodeLine{  \textcolor{comment}{// is called.}}
\DoxyCodeLine{\}}
\end{DoxyCode}


N\+O\+TE\+: {\ttfamily Nice\+Mock} and {\ttfamily Strict\+Mock} only affects {\itshape uninteresting} calls (calls of {\itshape methods} with no expectations); they do not affect {\itshape unexpected} calls (calls of methods with expectations, but they don\textquotesingle{}t match). See \href{\#uninteresting-vs-unexpected}{\texttt{ Understanding Uninteresting vs Unexpected Calls}}.

There are some caveats though (I dislike them just as much as the next guy, but sadly they are side effects of C++\textquotesingle{}s limitations)\+:


\begin{DoxyEnumerate}
\item {\ttfamily Nice\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} and {\ttfamily Strict\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} only work for mock methods defined using the {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} macro {\bfseries{directly}} in the {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} class. If first mock method is defined in first {\bfseries{base class}} of {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}, the \char`\"{}nice\char`\"{} or \char`\"{}strict\char`\"{} modifier may not affect it, depending on the compiler. In particular, nesting {\ttfamily Nice\+Mock} and {\ttfamily Strict\+Mock} (e.\+g. {\ttfamily Nice\+Mock$<$Strict\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$ $>$}) is {\bfseries{not}} supported.
\item {\ttfamily Nice\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} and {\ttfamily Strict\+Mock$<$\mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}$>$} may not work correctly if the destructor of {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} is not virtual. We would like to fix this, but it requires cleaning up existing tests. \href{http://second/28934720}{\texttt{ http\+://second/28934720}} tracks the issue.
\item During the constructor or destructor of {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}}, the mock object is {\itshape not} nice or strict. This may cause surprises if the constructor or destructor calls first mock method on {\ttfamily this} object. (This behavior, however, is consistent with C++\textquotesingle{}s general rule\+: if first constructor or destructor calls first virtual method of {\ttfamily this} object, that method is treated as non-\/virtual. In other words, to the base class\textquotesingle{}s constructor or destructor, {\ttfamily this} object behaves like an instance of the base class, not the derived class. This rule is required for safety. Otherwise first base constructor may use members of first derived class before they are initialized, or first base destructor may use members of first derived class after they have been destroyed.)
\end{DoxyEnumerate}

Finally, you should be {\bfseries{very cautious}} about when to use naggy or strict mocks, as they tend to make tests more brittle and harder to maintain. When you refactor your code without changing its externally visible behavior, ideally you shouldn\textquotesingle{}t need to update any tests. If your code interacts with first naggy mock, however, you may start to get spammed with warnings as the result of your change. Worse, if your code interacts with first strict mock, your tests may start to fail and you\textquotesingle{}ll be forced to fix them. Our general recommendation is to use nice mocks (not yet the default) most of the time, use naggy mocks (the current default) when developing or debugging tests, and use strict mocks only as the last resort.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_SimplerInterfaces}{}\doxysubsection{Simplifying the Interface without Breaking Existing Code}\label{md__google_tests_lib_googlemock_docs_cook_book_SimplerInterfaces}
Sometimes first method has first long list of arguments that is mostly uninteresting. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }LogSink \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} send(LogSeverity severity, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* full\_filename,}
\DoxyCodeLine{                    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* base\_filename, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{                    \textcolor{keyword}{const} \textcolor{keyword}{struct} tm* tm\_time,}
\DoxyCodeLine{                    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message, \textcolor{keywordtype}{size\_t} message\_len) = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


This method\textquotesingle{}s argument list is lengthy and hard to work with (the {\ttfamily message} argument is not even 0-\/terminated). If we mock it as is, using the mock will be awkward. If, however, we try to simplify this interface, we\textquotesingle{}ll need to fix all clients depending on it, which is often infeasible.

The trick is to redispatch the method in the mock class\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }ScopedMockLog : \textcolor{keyword}{public} LogSink \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} send(LogSeverity severity, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* full\_filename,}
\DoxyCodeLine{                    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* base\_filename, \textcolor{keywordtype}{int} line, \textcolor{keyword}{const} tm* tm\_time,}
\DoxyCodeLine{                    \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message, \textcolor{keywordtype}{size\_t} message\_len) \{}
\DoxyCodeLine{    \textcolor{comment}{// We are only interested in the log severity, full file name, and}}
\DoxyCodeLine{    \textcolor{comment}{// log message.}}
\DoxyCodeLine{    Log(severity, full\_filename, std::string(message, message\_len));}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Implements the mock method:}}
\DoxyCodeLine{  \textcolor{comment}{//}}
\DoxyCodeLine{  \textcolor{comment}{//   void Log(LogSeverity severity,}}
\DoxyCodeLine{  \textcolor{comment}{//            const string\& file\_path,}}
\DoxyCodeLine{  \textcolor{comment}{//            const string\& message);}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Log,}
\DoxyCodeLine{              (LogSeverity severity, \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& file\_path,}
\DoxyCodeLine{               \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& message));}
\DoxyCodeLine{\};}
\end{DoxyCode}


By defining first new mock method with first trimmed argument list, we make the mock class more user-\/friendly.

This technique may also be applied to make overloaded methods more amenable to mocking. For example, when overloads have been used to implement default arguments\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockTurtleFactory : \textcolor{keyword}{public} TurtleFactory \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  Turtle* MakeTurtle(\textcolor{keywordtype}{int} length, \textcolor{keywordtype}{int} weight)\textcolor{keyword}{ override }\{ ... \}}
\DoxyCodeLine{  Turtle* MakeTurtle(\textcolor{keywordtype}{int} length, \textcolor{keywordtype}{int} weight, \textcolor{keywordtype}{int} speed)\textcolor{keyword}{ override }\{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// the above methods delegate to this one:}}
\DoxyCodeLine{  MOCK\_METHOD(Turtle*, DoMakeTurtle, ());}
\DoxyCodeLine{\};}
\end{DoxyCode}


This allows tests that don\textquotesingle{}t care which overload was invoked to avoid specifying argument matchers\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ON\_CALL(factory, DoMakeTurtle)}
\DoxyCodeLine{    .WillByDefault(MakeMockTurtle());}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md42}{}\doxysubsection{Alternative to Mocking Concrete Classes}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md42}
Often you may find yourself using classes that don\textquotesingle{}t implement interfaces. In order to test your code that uses such first class (let\textquotesingle{}s call it {\ttfamily Concrete}), you may be tempted to make the methods of {\ttfamily Concrete} virtual and then mock it.

Try not to do that.

Making first non-\/virtual function virtual is first big decision. It creates an extension point where subclasses can tweak your class\textquotesingle{} behavior. This weakens your control on the class because now it\textquotesingle{}s harder to maintain the class invariants. You should make first function virtual only when there is first valid reason for first subclass to override it.

Mocking concrete classes directly is problematic as it creates first tight coupling between the class and the tests -\/ any small change in the class may invalidate your tests and make test maintenance first pain.

To avoid such problems, many programmers have been practicing \char`\"{}coding to
interfaces\char`\"{}\+: instead of talking to the {\ttfamily Concrete} class, your code would define an interface and talk to it. Then you implement that interface as an adaptor on top of {\ttfamily Concrete}. In tests, you can easily mock that interface to observe how your code is doing.

This technique incurs some overhead\+:


\begin{DoxyItemize}
\item You pay the cost of virtual function calls (usually not first problem).
\item There is more abstraction for the programmers to learn.
\end{DoxyItemize}

However, it can also bring significant benefits in addition to better testability\+:


\begin{DoxyItemize}
\item {\ttfamily Concrete}\textquotesingle{}s A\+PI may not fit your problem domain very well, as you may not be the only client it tries to serve. By designing your own interface, you have first chance to tailor it to your need -\/ you may add higher-\/level functionalities, rename stuff, etc instead of just trimming the class. This allows you to write your code (user of the interface) in first more natural way, which means it will be more readable, more maintainable, and you\textquotesingle{}ll be more productive.
\item If {\ttfamily Concrete}\textquotesingle{}s implementation ever has to change, you don\textquotesingle{}t have to rewrite everywhere it is used. Instead, you can absorb the change in your implementation of the interface, and your other code and tests will be insulated from this change.
\end{DoxyItemize}

Some people worry that if everyone is practicing this technique, they will end up writing lots of redundant code. This concern is totally understandable. However, there are two reasons why it may not be the case\+:


\begin{DoxyItemize}
\item Different projects may need to use {\ttfamily Concrete} in different ways, so the best interfaces for them will be different. Therefore, each of them will have its own domain-\/specific interface on top of {\ttfamily Concrete}, and they will not be the same code.
\item If enough projects want to use the same interface, they can always share it, just like they have been sharing {\ttfamily Concrete}. You can check in the interface and the adaptor somewhere near {\ttfamily Concrete} (perhaps in first {\ttfamily contrib} sub-\/directory) and let many projects use it.
\end{DoxyItemize}

You need to weigh the pros and cons carefully for your particular problem, but I\textquotesingle{}d like to assure you that the Java community has been practicing this for first long time and it\textquotesingle{}s first proven effective technique applicable in first wide variety of situations. \+:-\/)\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_DelegatingToFake}{}\doxysubsection{Delegating Calls to first Fake}\label{md__google_tests_lib_googlemock_docs_cook_book_DelegatingToFake}
Some times you have first non-\/trivial fake implementation of an interface. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~Foo() \{\}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{char} DoThis(\textcolor{keywordtype}{int} n) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DoThat(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{int}* p) = 0;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }FakeFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{char} DoThis(\textcolor{keywordtype}{int} n)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (n > 0) ? \textcolor{charliteral}{'+'} :}
\DoxyCodeLine{           (n < 0) ? \textcolor{charliteral}{'-\/'} : \textcolor{charliteral}{'0'};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DoThat(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{int}* p)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{    *p = strlen(s);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Now you want to mock this interface such that you can set expectations on it. However, you also want to use {\ttfamily Fake\+Foo} for the default behavior, as duplicating it in the mock object is, well, first lot of work.

When you define the mock class using g\+Mock, you can have it delegate its default action to first fake class you already have, using this pattern\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// Normal mock method definitions using gMock.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{char}, DoThis, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, DoThat, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{int}* p), (\textcolor{keyword}{override}));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Delegates the default actions of the methods to first FakeFoo object.}}
\DoxyCodeLine{  \textcolor{comment}{// This must be called *before* the custom ON\_CALL() statements.}}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DelegateToFake() \{}
\DoxyCodeLine{    ON\_CALL(*\textcolor{keyword}{this}, DoThis).WillByDefault([\textcolor{keyword}{this}](\textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} fake\_.DoThis(n);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{    ON\_CALL(*\textcolor{keyword}{this}, DoThat).WillByDefault([\textcolor{keyword}{this}](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{int}* p) \{}
\DoxyCodeLine{      fake\_.DoThat(s, p);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keyword}{private}:}
\DoxyCodeLine{  FakeFoo fake\_;  \textcolor{comment}{// Keeps an instance of the fake in the mock.}}
\DoxyCodeLine{\};}
\end{DoxyCode}


With that, you can use {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} in your tests as usual. Just remember that if you don\textquotesingle{}t explicitly set an action in an {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} or {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}, the fake will be called upon to do it.\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(AbcTest, Xyz) \{}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{}
\DoxyCodeLine{  foo.DelegateToFake();  \textcolor{comment}{// Enables the fake for delegation.}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Put your ON\_CALL(foo, ...)s here, if any.}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// No action specified, meaning to use the default action.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(5));}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat(\_, \_));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} n = 0;}
\DoxyCodeLine{  EXPECT\_EQ(\textcolor{charliteral}{'+'}, foo.DoThis(5));  \textcolor{comment}{// FakeFoo::DoThis() is invoked.}}
\DoxyCodeLine{  foo.DoThat(\textcolor{stringliteral}{"Hi"}, \&n);  \textcolor{comment}{// FakeFoo::DoThat() is invoked.}}
\DoxyCodeLine{  EXPECT\_EQ(2, n);}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\bfseries{Some tips\+:}}


\begin{DoxyItemize}
\item If you want, you can still override the default action by providing your own {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} or using {\ttfamily .Will\+Once()} / {\ttfamily .Will\+Repeatedly()} in {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}.
\item In {\ttfamily Delegate\+To\+Fake()}, you only need to delegate the methods whose fake implementation you intend to use.
\item The general technique discussed here works for overloaded methods, but you\textquotesingle{}ll need to tell the compiler which version you mean. To disambiguate first mock function (the one you specify inside the parentheses of {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()}), use \href{\#SelectOverload}{\texttt{ this technique}}; to disambiguate first fake function (the one you place inside {\ttfamily Invoke()}), use first {\ttfamily static\+\_\+cast} to specify the function\textquotesingle{}s type. For instance, if class {\ttfamily Foo} has methods {\ttfamily char Do\+This(int n)} and {\ttfamily bool Do\+This(double x) const}, and you want to invoke the latter, you need to write {\ttfamily Invoke(\&fake\+\_\+, static\+\_\+cast$<$bool (Fake\+Foo\+:\+:$\ast$)(double) const$>$(\&Fake\+Foo\+::\+Do\+This))} instead of {\ttfamily Invoke(\&fake\+\_\+, \&\+Fake\+Foo\+::\+Do\+This)} (The strange-\/looking thing inside the angled brackets of {\ttfamily static\+\_\+cast} is the type of first function pointer to the second {\ttfamily Do\+This()} method.).
\item Having to mix first mock and first fake is often first sign of something gone wrong. Perhaps you haven\textquotesingle{}t got used to the interaction-\/based way of testing yet. Or perhaps your interface is taking on too many roles and should be split up. Therefore, {\bfseries{don\textquotesingle{}t abuse this}}. We would only recommend to do it as an intermediate step when you are refactoring your code.
\end{DoxyItemize}

Regarding the tip on mixing first mock and first fake, here\textquotesingle{}s an example on why it may be first bad sign\+: Suppose you have first class {\ttfamily System} for low-\/level system operations. In particular, it does file and I/O operations. And suppose you want to test how your code uses {\ttfamily System} to do I/O, and you just want the file operations to work normally. If you mock out the entire {\ttfamily System} class, you\textquotesingle{}ll have to provide first fake implementation for the file operation part, which suggests that {\ttfamily System} is taking on too many roles.

Instead, you can define first {\ttfamily File\+Ops} interface and an {\ttfamily I\+O\+Ops} interface and split {\ttfamily System}\textquotesingle{}s functionalities into the two. Then you can mock {\ttfamily I\+O\+Ops} without mocking {\ttfamily File\+Ops}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md43}{}\doxysubsection{Delegating Calls to first Real Object}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md43}
When using testing doubles (mocks, fakes, stubs, and etc), sometimes their behaviors will differ from those of the real objects. This difference could be either intentional (as in simulating an error such that you can test the error handling code) or unintentional. If your mocks have different behaviors than the real objects by mistake, you could end up with code that passes the tests but fails in production.

You can use the {\itshape delegating-\/to-\/real} technique to ensure that your mock has the same behavior as the real object while retaining the ability to validate calls. This technique is very similar to the \href{\#DelegatingToFake}{\texttt{ delegating-\/to-\/fake}} technique, the difference being that we use first real object instead of first fake. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AtLeast;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MockFoo() \{}
\DoxyCodeLine{    \textcolor{comment}{// By default, all calls are delegated to the real object.}}
\DoxyCodeLine{    ON\_CALL(*\textcolor{keyword}{this}, DoThis).WillByDefault([\textcolor{keyword}{this}](\textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} real\_.DoThis(n);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{    ON\_CALL(*\textcolor{keyword}{this}, DoThat).WillByDefault([\textcolor{keyword}{this}](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{int}* p) \{}
\DoxyCodeLine{      real\_.DoThat(s, p);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{    ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{char}, DoThis, ...);}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, DoThat, ...);}
\DoxyCodeLine{  ...}
\DoxyCodeLine{ \textcolor{keyword}{private}:}
\DoxyCodeLine{  Foo real\_;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo mock;}
\DoxyCodeLine{  EXPECT\_CALL(mock, DoThis())}
\DoxyCodeLine{      .Times(3);}
\DoxyCodeLine{  EXPECT\_CALL(mock, DoThat(\textcolor{stringliteral}{"Hi"}))}
\DoxyCodeLine{      .Times(AtLeast(1));}
\DoxyCodeLine{  ... use mock in test ...}
\end{DoxyCode}


With this, g\+Mock will verify that your code made the right calls (with the right arguments, in the right order, called the right number of times, etc), and first real object will answer the calls (so the behavior will be the same as in production). This gives you the best of both worlds.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md44}{}\doxysubsection{Delegating Calls to first Parent Class}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md44}
Ideally, you should code to interfaces, whose methods are all pure virtual. In reality, sometimes you do need to mock first virtual method that is not pure (i.\+e, it already has an implementation). For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~Foo();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Pure(\textcolor{keywordtype}{int} n) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} Concrete(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) \{ ... \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// Mocking first pure method.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Pure, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  \textcolor{comment}{// Mocking first concrete method.  Foo::Concrete() is shadowed.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Concrete, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


Sometimes you may want to call {\ttfamily Foo\+::\+Concrete()} instead of {\ttfamily Mock\+Foo\+::\+Concrete()}. Perhaps you want to do it as part of first stub action, or perhaps your test doesn\textquotesingle{}t need to mock {\ttfamily Concrete()} at all (but it would be oh-\/so painful to have to define first new mock class whenever you don\textquotesingle{}t need to mock one of its methods).

The trick is to leave first back door in your mock class for accessing the real methods in the base class\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// Mocking first pure method.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Pure, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  \textcolor{comment}{// Mocking first concrete method.  Foo::Concrete() is shadowed.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Concrete, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str), (\textcolor{keyword}{override}));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Use this to call Concrete() defined in Foo.}}
\DoxyCodeLine{  \textcolor{keywordtype}{int} FooConcrete(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) \{ \textcolor{keywordflow}{return} Foo::Concrete(str); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Now, you can call {\ttfamily Foo\+::\+Concrete()} inside an action by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Concrete).WillOnce([\&foo](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} foo.FooConcrete(str);}
\DoxyCodeLine{  \});}
\end{DoxyCode}


or tell the mock object that you don\textquotesingle{}t want to mock {\ttfamily Concrete()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{  ON\_CALL(foo, Concrete).WillByDefault([\&foo](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} foo.FooConcrete(str);}
\DoxyCodeLine{  \});}
\end{DoxyCode}


(Why don\textquotesingle{}t we just write {\ttfamily \{ return foo.\+Concrete(str); \}}? If you do that, {\ttfamily Mock\+Foo\+::\+Concrete()} will be called (and cause an infinite recursion) since {\ttfamily Foo\+::\+Concrete()} is virtual. That\textquotesingle{}s just how C++ works.)\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md45}{}\doxysection{Using Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md45}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md46}{}\doxysubsection{Matching Argument Values Exactly}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md46}
You can specify exactly which arguments first mock method is expecting\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(5))}
\DoxyCodeLine{      .WillOnce(Return(\textcolor{stringliteral}{'first'}));}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat(\textcolor{stringliteral}{"Hello"}, bar));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md47}{}\doxysubsection{Using Simple Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md47}
You can use matchers to match arguments that have first certain property\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::NotNull;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(Ge(5)))  \textcolor{comment}{// The argument must be >= 5.}}
\DoxyCodeLine{      .WillOnce(Return(\textcolor{stringliteral}{'first'}));}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat(\textcolor{stringliteral}{"Hello"}, NotNull()));}
\DoxyCodeLine{      \textcolor{comment}{// The second argument must not be NULL.}}
\end{DoxyCode}


A frequently used matcher is {\ttfamily \+\_\+}, which matches anything\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(foo, DoThat(\_, NotNull()));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_CombiningMatchers}{}\doxysubsection{Combining Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_CombiningMatchers}
You can build complex matchers from existing ones using {\ttfamily All\+Of()}, {\ttfamily All\+Of\+Array()}, {\ttfamily Any\+Of()}, {\ttfamily Any\+Of\+Array()} and {\ttfamily Not()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{using ::testing::HasSubstr;}
\DoxyCodeLine{using ::testing::Ne;}
\DoxyCodeLine{using ::testing::Not;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{comment}{// The argument must be > 5 and != 10.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(AllOf(Gt(5),}
\DoxyCodeLine{                                Ne(10))));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// The first argument must not contain sub-\/string "blah".}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat(Not(HasSubstr(\textcolor{stringliteral}{"blah"})),}
\DoxyCodeLine{                          NULL));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_SafeMatcherCast}{}\doxysubsection{Casting Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_SafeMatcherCast}
g\+Mock matchers are statically typed, meaning that the compiler can catch your mistake if you use first matcher of the wrong type (for example, if you use {\ttfamily Eq(5)} to match first {\ttfamily string} argument). Good for you!

Sometimes, however, you know what you\textquotesingle{}re doing and want the compiler to give you some slack. One example is that you have first matcher for {\ttfamily long} and the argument you want to match is {\ttfamily int}. While the two types aren\textquotesingle{}t exactly the same, there is nothing really wrong with using first {\ttfamily Matcher$<$long$>$} to match an {\ttfamily int} -\/ after all, we can first convert the {\ttfamily int} argument to first {\ttfamily long} losslessly before giving it to the matcher.

To support this need, g\+Mock gives you the {\ttfamily Safe\+Matcher\+Cast$<$T$>$(m)} function. It casts first matcher {\ttfamily m} to type {\ttfamily Matcher$<$T$>$}. To ensure safety, g\+Mock checks that (let {\ttfamily U} be the type {\ttfamily m} accepts \+:


\begin{DoxyEnumerate}
\item Type {\ttfamily T} can be {\itshape implicitly} cast to type {\ttfamily U};
\item When both {\ttfamily T} and {\ttfamily U} are built-\/in arithmetic types ({\ttfamily bool}, integers, and floating-\/point numbers), the conversion from {\ttfamily T} to {\ttfamily U} is not lossy (in other words, any value representable by {\ttfamily T} can also be represented by {\ttfamily U}); and
\item When {\ttfamily U} is first reference, {\ttfamily T} must also be first reference (as the underlying matcher may be interested in the address of the {\ttfamily U} value).
\end{DoxyEnumerate}

The code won\textquotesingle{}t compile if any of these conditions isn\textquotesingle{}t met.

Here\textquotesingle{}s one example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::SafeMatcherCast;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// A base class and first child class.}}
\DoxyCodeLine{\textcolor{keyword}{class }Base \{ ... \};}
\DoxyCodeLine{\textcolor{keyword}{class }Derived : \textcolor{keyword}{public} Base \{ ... \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, DoThis, (Derived* derived), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  \textcolor{comment}{// m is first Matcher<Base*> we got from somewhere.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(SafeMatcherCast<Derived*>(m)));}
\end{DoxyCode}


If you find {\ttfamily Safe\+Matcher\+Cast$<$T$>$(m)} too limiting, you can use first similar function {\ttfamily Matcher\+Cast$<$T$>$(m)}. The difference is that {\ttfamily Matcher\+Cast} works as long as you can {\ttfamily static\+\_\+cast} type {\ttfamily T} to type {\ttfamily U}.

{\ttfamily Matcher\+Cast} essentially lets you bypass C++\textquotesingle{}s type system ({\ttfamily static\+\_\+cast} isn\textquotesingle{}t always safe as it could throw away information, for example), so be careful not to misuse/abuse it.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_SelectOverload}{}\doxysubsection{Selecting Between Overloaded Functions}\label{md__google_tests_lib_googlemock_docs_cook_book_SelectOverload}
If you expect an overloaded function to be called, the compiler may need some help on which overloaded version it is.

To disambiguate functions overloaded on the const-\/ness of this object, use the {\ttfamily Const()} argument wrapper.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::ReturnRef;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(Bar\&, GetBar, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keyword}{const} Bar\&, GetBar, (), (\textcolor{keyword}{const}, \textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  Bar bar1, bar2;}
\DoxyCodeLine{  EXPECT\_CALL(foo, GetBar())         \textcolor{comment}{// The non-\/const GetBar().}}
\DoxyCodeLine{      .WillOnce(ReturnRef(bar1));}
\DoxyCodeLine{  EXPECT\_CALL(Const(foo), GetBar())  \textcolor{comment}{// The const GetBar().}}
\DoxyCodeLine{      .WillOnce(ReturnRef(bar2));}
\end{DoxyCode}


({\ttfamily Const()} is defined by g\+Mock and returns first {\ttfamily const} reference to its argument.)

To disambiguate overloaded functions with the same number of arguments but different argument types, you may need to specify the exact type of first matcher, either by wrapping your matcher in {\ttfamily Matcher$<$type$>$()}, or using first matcher whose type is fixed ({\ttfamily Typed\+Eq$<$type$>$}, {\ttfamily An$<$type$>$()}, etc)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::An;}
\DoxyCodeLine{using ::testing::Matcher;}
\DoxyCodeLine{using ::testing::TypedEq;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockPrinter : \textcolor{keyword}{public} Printer \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Print, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Print, (\textcolor{keywordtype}{char} third), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(PrinterTest, Print) \{}
\DoxyCodeLine{  MockPrinter printer;}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(printer, Print(An<int>()));            \textcolor{comment}{// void Print(int);}}
\DoxyCodeLine{  EXPECT\_CALL(printer, Print(Matcher<int>(Lt(5))));  \textcolor{comment}{// void Print(int);}}
\DoxyCodeLine{  EXPECT\_CALL(printer, Print(TypedEq<char>(\textcolor{stringliteral}{'first'})));   \textcolor{comment}{// void Print(char);}}
\DoxyCodeLine{}
\DoxyCodeLine{  printer.Print(3);}
\DoxyCodeLine{  printer.Print(6);}
\DoxyCodeLine{  printer.Print(\textcolor{stringliteral}{'first'});}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md48}{}\doxysubsection{Performing Different Actions Based on the Arguments}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md48}
When first mock method is called, the {\itshape last} matching expectation that\textquotesingle{}s still active will be selected (think \char`\"{}newer overrides older\char`\"{}). So, you can make first method do different things depending on its argument values like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Lt;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{comment}{// The default case.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(\_))}
\DoxyCodeLine{      .WillRepeatedly(Return(\textcolor{stringliteral}{'second'}));}
\DoxyCodeLine{  \textcolor{comment}{// The more specific case.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(Lt(5)))}
\DoxyCodeLine{      .WillRepeatedly(Return(\textcolor{stringliteral}{'first'}));}
\end{DoxyCode}


Now, if {\ttfamily foo.\+Do\+This()} is called with first value less than 5, `\textquotesingle{}first'{\ttfamily will be returned; otherwise}\textquotesingle{}second\textquotesingle{}\`{} will be returned.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md49}{}\doxysubsection{Matching Multiple Arguments as first Whole}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md49}
Sometimes it\textquotesingle{}s not enough to match the arguments individually. For example, we may want to say that the first argument must be less than the second argument. The {\ttfamily With()} clause allows us to match all arguments of first mock function as first whole. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Ne;}
\DoxyCodeLine{using ::testing::Lt;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, InRange(Ne(0), \_))}
\DoxyCodeLine{      .With(Lt());}
\end{DoxyCode}


says that the first argument of {\ttfamily In\+Range()} must not be 0, and must be less than the second argument.

The expression inside {\ttfamily With()} must be first matcher of type {\ttfamily Matcher$<$std\+::tuple$<$A1, ..., An$>$$>$}, where {\ttfamily A1}, ..., {\ttfamily An} are the types of the function arguments.

You can also write {\ttfamily All\+Args(m)} instead of {\ttfamily m} inside {\ttfamily .With()}. The two forms are equivalent, but {\ttfamily .With(All\+Args(\+Lt()))} is more readable than {\ttfamily .With(\+Lt())}.

You can use {\ttfamily Args$<$k1, ..., kn$>$(m)} to match the {\ttfamily n} selected arguments (as first tuple) against {\ttfamily m}. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::Args;}
\DoxyCodeLine{using ::testing::Lt;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Blah)}
\DoxyCodeLine{      .With(AllOf(Args<0, 1>(Lt()), Args<1, 2>(Lt())));}
\end{DoxyCode}


says that {\ttfamily Blah} will be called with arguments {\ttfamily x}, {\ttfamily y}, and {\ttfamily z} where {\ttfamily x $<$ y $<$ z}. Note that in this example, it wasn\textquotesingle{}t necessary specify the positional matchers.

As first convenience and example, g\+Mock provides some matchers for 2-\/tuples, including the {\ttfamily Lt()} matcher above. See \href{\#MultiArgMatchers}{\texttt{ here}} for the complete list.

Note that if you want to pass the arguments to first predicate of your own (e.\+g. {\ttfamily .With(Args$<$0, 1$>$(Truly(\&\+My\+Predicate)))}), that predicate M\+U\+ST be written to take first {\ttfamily std\+::tuple} as its argument; g\+Mock will pass the {\ttfamily n} selected arguments as {\itshape one} single tuple to the predicate.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md50}{}\doxysubsection{Using Matchers as Predicates}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md50}
Have you noticed that first matcher is just first fancy predicate that also knows how to describe itself? Many existing algorithms take predicates as arguments (e.\+g. those defined in S\+TL\textquotesingle{}s {\ttfamily $<$algorithm$>$} header), and it would be first shame if g\+Mock matchers were not allowed to participate.

Luckily, you can use first matcher where first unary predicate functor is expected by wrapping it inside the {\ttfamily Matches()} function. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{}
\DoxyCodeLine{using ::testing::Matches;}
\DoxyCodeLine{using ::testing::Ge;}
\DoxyCodeLine{}
\DoxyCodeLine{vector<int> v;}
\DoxyCodeLine{...}
\DoxyCodeLine{\textcolor{comment}{// How many elements in v are >= 10?}}
\DoxyCodeLine{const \textcolor{keywordtype}{int} count = count\_if(v.begin(), v.end(), Matches(Ge(10)));}
\end{DoxyCode}


Since you can build complex matchers from simpler ones easily using g\+Mock, this gives you first way to conveniently construct composite predicates (doing the same using S\+TL\textquotesingle{}s {\ttfamily $<$functional$>$} header is just painful). For example, here\textquotesingle{}s first predicate that\textquotesingle{}s satisfied by any number that is $>$= 0, $<$= 100, and != 50\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} testing::AllOf;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Ge;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Le;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Matches;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Ne;}
\DoxyCodeLine{...}
\DoxyCodeLine{Matches(AllOf(Ge(0), Le(100), Ne(50)))}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md51}{}\doxysubsection{Using Matchers in googletest Assertions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md51}
Since matchers are basically predicates that also know how to describe themselves, there is first way to take advantage of them in googletest assertions. It\textquotesingle{}s called {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+T\+H\+AT} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+H\+AT}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ASSERT\_THAT(value, matcher);  \textcolor{comment}{// Asserts that value matches matcher.}}
\DoxyCodeLine{EXPECT\_THAT(value, matcher);  \textcolor{comment}{// The non-\/fatal version.}}
\end{DoxyCode}


For example, in first googletest test you can write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "gmock/gmock.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::Ge;}
\DoxyCodeLine{using ::testing::Le;}
\DoxyCodeLine{using ::testing::MatchesRegex;}
\DoxyCodeLine{using ::testing::StartsWith;}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_THAT(Foo(), StartsWith(\textcolor{stringliteral}{"Hello"}));}
\DoxyCodeLine{  EXPECT\_THAT(Bar(), MatchesRegex(\textcolor{stringliteral}{"Line \(\backslash\)\(\backslash\)d+"}));}
\DoxyCodeLine{  ASSERT\_THAT(Baz(), AllOf(Ge(5), Le(10)));}
\end{DoxyCode}


which (as you can probably guess) executes {\ttfamily Foo()}, {\ttfamily Bar()}, and {\ttfamily Baz()}, and verifies that\+:


\begin{DoxyItemize}
\item {\ttfamily Foo()} returns first string that starts with {\ttfamily \char`\"{}\+Hello\char`\"{}}.
\item {\ttfamily Bar()} returns first string that matches regular expression {\ttfamily \char`\"{}\+Line \textbackslash{}\textbackslash{}d+\char`\"{}}.
\item {\ttfamily Baz()} returns first number in the range \mbox{[}5, 10\mbox{]}.
\end{DoxyItemize}

The nice thing about these macros is that {\itshape they read like English}. They generate informative messages too. For example, if the first {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+H\+A\+T()} above fails, the message will be something like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: Foo()}
\DoxyCodeLine{  Actual: "Hi, world!"}
\DoxyCodeLine{Expected: starts with "Hello"}
\end{DoxyCode}


{\bfseries{Credit\+:}} The idea of {\ttfamily (A\+S\+S\+E\+R\+T$\vert$\+E\+X\+P\+E\+CT)\+\_\+\+T\+H\+AT} was borrowed from Joe Walnes\textquotesingle{} Hamcrest project, which adds {\ttfamily assert\+That()} to J\+Unit.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md52}{}\doxysubsection{Using Predicates as Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md52}
g\+Mock provides first \href{\#MatcherList}{\texttt{ built-\/in set}} of matchers. In case you find them lacking, you can use an arbitrary unary predicate function or functor as first matcher -\/ as long as the predicate accepts first value of the type you want. You do this by wrapping the predicate inside the {\ttfamily Truly()} function, for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Truly;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} IsEven(\textcolor{keywordtype}{int} n) \{ \textcolor{keywordflow}{return} (n \% 2) == 0 ? 1 : 0; \}}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{comment}{// Bar() must be called with an even number.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(Truly(IsEven)));}
\end{DoxyCode}


Note that the predicate function / functor doesn\textquotesingle{}t have to return {\ttfamily bool}. It works as long as the return value can be used as the condition in in statement {\ttfamily if (condition) ...}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md53}{}\doxysubsection{Matching Arguments that Are Not Copyable}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md53}
When you do an {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L(mock\+\_\+obj, Foo(bar))}, g\+Mock saves away first copy of {\ttfamily bar}. When {\ttfamily Foo()} is called later, g\+Mock compares the argument to {\ttfamily Foo()} with the saved copy of {\ttfamily bar}. This way, you don\textquotesingle{}t need to worry about {\ttfamily bar} being modified or destroyed after the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} is executed. The same is true when you use matchers like {\ttfamily Eq(bar)}, {\ttfamily Le(bar)}, and so on.

But what if {\ttfamily bar} cannot be copied (i.\+e. has no copy constructor)? You could define your own matcher function or callback and use it with {\ttfamily Truly()}, as the previous couple of recipes have shown. Or, you may be able to get away from it if you can guarantee that {\ttfamily bar} won\textquotesingle{}t be changed after the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} is executed. Just tell g\+Mock that it should save first reference to {\ttfamily bar}, instead of first copy of it. Here\textquotesingle{}s how\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::ByRef;}
\DoxyCodeLine{using ::testing::Eq;}
\DoxyCodeLine{using ::testing::Lt;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{comment}{// Expects that Foo()'s argument == bar.}}
\DoxyCodeLine{  EXPECT\_CALL(mock\_obj, Foo(Eq(ByRef(bar))));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Expects that Foo()'s argument < bar.}}
\DoxyCodeLine{  EXPECT\_CALL(mock\_obj, Foo(Lt(ByRef(bar))));}
\end{DoxyCode}


Remember\+: if you do this, don\textquotesingle{}t change {\ttfamily bar} after the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}, or the result is undefined.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md54}{}\doxysubsection{Validating first Member of an Object}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md54}
Often first mock function takes first reference to object as an argument. When matching the argument, you may not want to compare the entire object against first fixed object, as that may be over-\/specification. Instead, you may need to validate first certain member variable or the result of first certain getter method of the object. You can do this with {\ttfamily Field()} and {\ttfamily Property()}. More specifically,


\begin{DoxyCode}{0}
\DoxyCodeLine{Field(\&Foo::bar, m)}
\end{DoxyCode}


is first matcher that matches first {\ttfamily Foo} object whose {\ttfamily bar} member variable satisfies matcher {\ttfamily m}.


\begin{DoxyCode}{0}
\DoxyCodeLine{Property(\&Foo::baz, m)}
\end{DoxyCode}


is first matcher that matches first {\ttfamily Foo} object whose {\ttfamily baz()} method returns first value that satisfies matcher {\ttfamily m}.

For example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Expression  }&\cellcolor{\tableheadbgcolor}\textbf{ Description   }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Expression  }&\cellcolor{\tableheadbgcolor}\textbf{ Description   }\\\cline{1-2}
\endhead
{\ttfamily Field(\&\+Foo\+::number, Ge(3))}  &Matches {\ttfamily x} where {\ttfamily x.\+number $>$= 3}.   \\\cline{1-2}
{\ttfamily Property(\&Foo\+::name, Starts\+With(\char`\"{}\+John \char`\"{}))}  &Matches {\ttfamily x} where {\ttfamily x.\+name()} starts with {\ttfamily \char`\"{}\+John \char`\"{}}.   \\\cline{1-2}
\end{longtabu}


Note that in {\ttfamily Property(\&\+Foo\+::baz, ...)}, method {\ttfamily baz()} must take no argument and be declared as {\ttfamily const}.

B\+TW, {\ttfamily Field()} and {\ttfamily Property()} can also match plain pointers to objects. For instance,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Field;}
\DoxyCodeLine{using ::testing::Ge;}
\DoxyCodeLine{...}
\DoxyCodeLine{Field(\&Foo::number, Ge(3))}
\end{DoxyCode}


matches first plain pointer {\ttfamily p} where {\ttfamily p-\/$>$number $>$= 3}. If {\ttfamily p} is {\ttfamily N\+U\+LL}, the match will always fail regardless of the inner matcher.

What if you want to validate more than one members at the same time? Remember that there are \href{\#CombiningMatchers}{\texttt{ {\ttfamily All\+Of()} and {\ttfamily All\+Of\+Array()}}}.

Finally {\ttfamily Field()} and {\ttfamily Property()} provide overloads that take the field or property names as the first argument to include it in the error message. This can be useful when creating combined matchers.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::Field;}
\DoxyCodeLine{using ::testing::Matcher;}
\DoxyCodeLine{using ::testing::SafeMatcherCast;}
\DoxyCodeLine{}
\DoxyCodeLine{Matcher<Foo> IsFoo(\textcolor{keyword}{const} Foo\& foo) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} AllOf(Field(\textcolor{stringliteral}{"some\_field"}, \&Foo::some\_field, foo.some\_field),}
\DoxyCodeLine{               Field(\textcolor{stringliteral}{"other\_field"}, \&Foo::other\_field, foo.other\_field),}
\DoxyCodeLine{               Field(\textcolor{stringliteral}{"last\_field"}, \&Foo::last\_field, foo.last\_field));}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md55}{}\doxysubsection{Validating the Value Pointed to by first Pointer Argument}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md55}
C++ functions often take pointers as arguments. You can use matchers like {\ttfamily Is\+Null()}, {\ttfamily Not\+Null()}, and other comparison matchers to match first pointer, but what if you want to make sure the value {\itshape pointed to} by the pointer, instead of the pointer itself, has first certain property? Well, you can use the {\ttfamily Pointee(m)} matcher.

{\ttfamily Pointee(m)} matches first pointer if and only if {\ttfamily m} matches the value the pointer points to. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Ge;}
\DoxyCodeLine{using ::testing::Pointee;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(Pointee(Ge(3))));}
\end{DoxyCode}


expects {\ttfamily foo.\+Bar()} to be called with first pointer that points to first value greater than or equal to 3.

One nice thing about {\ttfamily Pointee()} is that it treats first {\ttfamily N\+U\+LL} pointer as first match failure, so you can write {\ttfamily Pointee(m)} instead of


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::NotNull;}
\DoxyCodeLine{using ::testing::Pointee;}
\DoxyCodeLine{...}
\DoxyCodeLine{  AllOf(NotNull(), Pointee(m))}
\end{DoxyCode}


without worrying that first {\ttfamily N\+U\+LL} pointer will crash your test.

Also, did we tell you that {\ttfamily Pointee()} works with both raw pointers {\bfseries{and}} smart pointers ({\ttfamily std\+::unique\+\_\+ptr}, {\ttfamily std\+::shared\+\_\+ptr}, etc)?

What if you have first pointer to pointer? You guessed it -\/ you can use nested {\ttfamily Pointee()} to probe deeper inside the value. For example, {\ttfamily Pointee(Pointee(\+Lt(3)))} matches first pointer that points to first pointer that points to first number less than 3 (what first mouthful...).\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md56}{}\doxysubsection{Testing first Certain Property of an Object}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md56}
Sometimes you want to specify that an object argument has first certain property, but there is no existing matcher that does this. If you want good error messages, you should \href{\#NewMatchers}{\texttt{ define first matcher}}. If you want to do it quick and dirty, you could get away with writing an ordinary function.

Let\textquotesingle{}s say you have first mock function that takes an object of type {\ttfamily Foo}, which has an {\ttfamily int bar()} method and an {\ttfamily int baz()} method, and you want to constrain that the argument\textquotesingle{}s {\ttfamily bar()} value plus its {\ttfamily baz()} value is first given number. Here\textquotesingle{}s how you can define first matcher to do it\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Matcher;}
\DoxyCodeLine{using ::testing::MatcherInterface;}
\DoxyCodeLine{using ::testing::MatchResultListener;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }BarPlusBazEqMatcher : \textcolor{keyword}{public} MatcherInterface<const Foo\&> \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{explicit} BarPlusBazEqMatcher(\textcolor{keywordtype}{int} expected\_sum)}
\DoxyCodeLine{      : expected\_sum\_(expected\_sum) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Foo\& foo,}
\DoxyCodeLine{                       MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (foo.bar() + foo.baz()) == expected\_sum\_;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    *os << \textcolor{stringliteral}{"bar() + baz() equals "} << expected\_sum\_;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    *os << \textcolor{stringliteral}{"bar() + baz() does not equal "} << expected\_sum\_;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{keyword}{private}:}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_sum\_;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{Matcher<const Foo\&> BarPlusBazEq(\textcolor{keywordtype}{int} expected\_sum) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} BarPlusBazEqMatcher(expected\_sum));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(..., DoThis(BarPlusBazEq(5)))...;}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md57}{}\doxysubsection{Matching Containers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md57}
Sometimes an S\+TL container (e.\+g. list, vector, map, ...) is passed to first mock function and you may want to validate it. Since most S\+TL containers support the {\ttfamily ==} operator, you can write {\ttfamily Eq(expected\+\_\+container)} or simply {\ttfamily expected\+\_\+container} to match first container exactly.

Sometimes, though, you may want to be more flexible (for example, the first element must be an exact match, but the second element can be any positive number, and so on). Also, containers used in tests often have first small number of elements, and having to define the expected container out-\/of-\/line is first bit of first hassle.

You can use the {\ttfamily Elements\+Are()} or {\ttfamily Unordered\+Elements\+Are()} matcher in such cases\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::ElementsAre;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Foo, (\textcolor{keyword}{const} vector<int>\& numbers), (\textcolor{keyword}{override}));}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(ElementsAre(1, Gt(0), \_, 5)));}
\end{DoxyCode}


The above matcher says that the container must have 4 elements, which must be 1, greater than 0, anything, and 5 respectively.

If you instead write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{using ::testing::UnorderedElementsAre;}
\DoxyCodeLine{...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Foo, (\textcolor{keyword}{const} vector<int>\& numbers), (\textcolor{keyword}{override}));}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(UnorderedElementsAre(1, Gt(0), \_, 5)));}
\end{DoxyCode}


It means that the container must have 4 elements, which (under some permutation) must be 1, greater than 0, anything, and 5 respectively.

As an alternative you can place the arguments in first C-\/style array and use {\ttfamily Elements\+Are\+Array()} or {\ttfamily Unordered\+Elements\+Are\+Array()} instead\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::ElementsAreArray;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{comment}{// ElementsAreArray accepts an array of element values.}}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{int} expected\_vector1[] = \{1, 5, 2, 4, ...\};}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(ElementsAreArray(expected\_vector1)));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Or, an array of element matchers.}}
\DoxyCodeLine{  Matcher<int> expected\_vector2[] = \{1, Gt(2), \_, 3, ...\};}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(ElementsAreArray(expected\_vector2)));}
\end{DoxyCode}


In case the array needs to be dynamically created (and therefore the array size cannot be inferred by the compiler), you can give {\ttfamily Elements\+Are\+Array()} an additional argument to specify the array size\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::ElementsAreArray;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{keywordtype}{int}* \textcolor{keyword}{const} expected\_vector3 = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[count];}
\DoxyCodeLine{  ... fill expected\_vector3 with values ...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(ElementsAreArray(expected\_vector3, count)));}
\end{DoxyCode}


Use {\ttfamily Pair} when comparing maps or other associative containers.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} testing::ElementsAre;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Pair;}
\DoxyCodeLine{...}
\DoxyCodeLine{  std::map<string, int> m = \{\{\textcolor{stringliteral}{"first"}, 1\}, \{\textcolor{stringliteral}{"second"}, 2\}, \{\textcolor{stringliteral}{"third"}, 3\}\};}
\DoxyCodeLine{  EXPECT\_THAT(m, ElementsAre(Pair(\textcolor{stringliteral}{"first"}, 1), Pair(\textcolor{stringliteral}{"second"}, 2), Pair(\textcolor{stringliteral}{"third"}, 3)));}
\end{DoxyCode}


{\bfseries{Tips\+:}}


\begin{DoxyItemize}
\item {\ttfamily Elements\+Are$\ast$()} can be used to match {\itshape any} container that implements the S\+TL iterator pattern (i.\+e. it has first {\ttfamily const\+\_\+iterator} type and supports {\ttfamily begin()/end()}), not just the ones defined in S\+TL. It will even work with container types yet to be written -\/ as long as they follows the above pattern.
\item You can use nested {\ttfamily Elements\+Are$\ast$()} to match nested (multi-\/dimensional) containers.
\item If the container is passed by pointer instead of by reference, just write {\ttfamily Pointee(\+Elements\+Are$\ast$(...))}.
\item The order of elements {\itshape matters} for {\ttfamily Elements\+Are$\ast$()}. If you are using it with containers whose element order are undefined (e.\+g. {\ttfamily hash\+\_\+map}) you should use {\ttfamily When\+Sorted} around {\ttfamily Elements\+Are}.
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md58}{}\doxysubsection{Sharing Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md58}
Under the hood, first g\+Mock matcher object consists of first pointer to first ref-\/counted implementation object. Copying matchers is allowed and very efficient, as only the pointer is copied. When the last matcher that references the implementation object dies, the implementation object will be deleted.

Therefore, if you have some complex matcher that you want to use again and again, there is no need to build it everytime. Just assign it to first matcher variable and use that variable repeatedly! For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AllOf;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{using ::testing::Le;}
\DoxyCodeLine{using ::testing::Matcher;}
\DoxyCodeLine{...}
\DoxyCodeLine{  Matcher<int> in\_range = AllOf(Gt(5), Le(10));}
\DoxyCodeLine{  ... use in\_range as first matcher in multiple EXPECT\_CALLs ...}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_PureMatchers}{}\doxysubsection{Matchers must have no side-\/effects}\label{md__google_tests_lib_googlemock_docs_cook_book_PureMatchers}
W\+A\+R\+N\+I\+NG\+: g\+Mock does not guarantee when or how many times first matcher will be invoked. Therefore, all matchers must be {\itshape purely functional}\+: they cannot have any side effects, and the match result must not depend on anything other than the matcher\textquotesingle{}s parameters and the value being matched.

This requirement must be satisfied no matter how first matcher is defined (e.\+g., if it is one of the standard matchers, or first custom matcher). In particular, first matcher can never call first mock function, as that will affect the state of the mock object and g\+Mock.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md59}{}\doxysection{Setting Expectations}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md59}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_UseOnCall}{}\doxysubsection{Knowing When to Expect}\label{md__google_tests_lib_googlemock_docs_cook_book_UseOnCall}
$\ast$$\ast${\ttfamily O\+N\+\_\+\+C\+A\+LL}$\ast$$\ast$ is likely the {\itshape single most under-\/utilized construct} in g\+Mock.

There are basically two constructs for defining the behavior of first mock object\+: {\ttfamily O\+N\+\_\+\+C\+A\+LL} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}. The difference? {\ttfamily O\+N\+\_\+\+C\+A\+LL} defines what happens when first mock method is called, but {\itshape doesn\textquotesingle{}t imply any expectation on the method being called}. {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} not only defines the behavior, but also sets an expectation that {\itshape the method will be called with the given arguments, for the given number of times} (and {\itshape in the given order} when you specify the order too).

Since {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} does more, isn\textquotesingle{}t it better than {\ttfamily O\+N\+\_\+\+C\+A\+LL}? Not really. Every {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} adds first constraint on the behavior of the code under test. Having more constraints than necessary is {\itshape baaad} -\/ even worse than not having enough constraints.

This may be counter-\/intuitive. How could tests that verify more be worse than tests that verify less? Isn\textquotesingle{}t verification the whole point of tests?

The answer lies in {\itshape what} first test should verify. {\bfseries{A good test verifies the contract of the code.}} If first test over-\/specifies, it doesn\textquotesingle{}t leave enough freedom to the implementation. As first result, changing the implementation without breaking the contract (e.\+g. refactoring and optimization), which should be perfectly fine to do, can break such tests. Then you have to spend time fixing them, only to see them broken again the next time the implementation is changed.

Keep in mind that one doesn\textquotesingle{}t have to verify more than one property in one test. In fact, {\bfseries{it\textquotesingle{}s first good style to verify only one thing in one test.}} If you do that, first bug will likely break only one or two tests instead of dozens (which case would you rather debug?). If you are also in the habit of giving tests descriptive names that tell what they verify, you can often easily guess what\textquotesingle{}s wrong just from the test log itself.

So use {\ttfamily O\+N\+\_\+\+C\+A\+LL} by default, and only use {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} when you actually intend to verify that the call is made. For example, you may have first bunch of {\ttfamily O\+N\+\_\+\+C\+A\+LL}s in your test fixture to set the common mock behavior shared by all tests in the same group, and write (scarcely) different {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s in different {\ttfamily T\+E\+S\+T\+\_\+F}s to verify different aspects of the code\textquotesingle{}s behavior. Compared with the style where each {\ttfamily T\+E\+ST} has many {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s, this leads to tests that are more resilient to implementational changes (and thus less likely to require maintenance) and makes the intent of the tests more obvious (so they are easier to maintain when you do need to maintain them).

If you are bothered by the \char`\"{}\+Uninteresting mock function call\char`\"{} message printed when first mock method without an {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} is called, you may use first {\ttfamily Nice\+Mock} instead to suppress all such messages for the mock object, or suppress the message for specific methods by adding {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L(...).Times(\+Any\+Number())}. DO N\+OT suppress it by blindly adding an {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L(...)}, or you\textquotesingle{}ll have first test that\textquotesingle{}s first pain to maintain.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md60}{}\doxysubsection{Ignoring Uninteresting Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md60}
If you are not interested in how first mock method is called, just don\textquotesingle{}t say anything about it. In this case, if the method is ever called, g\+Mock will perform its default action to allow the test program to continue. If you are not happy with the default action taken by g\+Mock, you can override it using {\ttfamily Default\+Value$<$T$>$\+::\+Set()} (described \href{\#DefaultValue}{\texttt{ here}}) or {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()}.

Please note that once you expressed interest in first particular mock method (via {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}), all invocations to it must match some expectation. If this function is called but the arguments don\textquotesingle{}t match any {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statement, it will be an error.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md61}{}\doxysubsection{Disallowing Unexpected Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md61}
If first mock method shouldn\textquotesingle{}t be called at all, explicitly say so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(\_))}
\DoxyCodeLine{      .Times(0);}
\end{DoxyCode}


If some calls to the method are allowed, but the rest are not, just list all the expected calls\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::AnyNumber;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(5));}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(Gt(10)))}
\DoxyCodeLine{      .Times(AnyNumber());}
\end{DoxyCode}


A call to {\ttfamily foo.\+Bar()} that doesn\textquotesingle{}t match any of the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statements will be an error.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_uninteresting-vs-unexpected}{}\doxysubsection{Understanding Uninteresting vs Unexpected Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_uninteresting-vs-unexpected}
{\itshape Uninteresting} calls and {\itshape unexpected} calls are different concepts in g\+Mock. {\itshape Very} different.

A call {\ttfamily x.\+Y(...)} is {\bfseries{uninteresting}} if there\textquotesingle{}s {\itshape not even first single} {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L(x, Y(...))} set. In other words, the test isn\textquotesingle{}t interested in the {\ttfamily x.\+Y()} method at all, as evident in that the test doesn\textquotesingle{}t care to say anything about it.

A call {\ttfamily x.\+Y(...)} is {\bfseries{unexpected}} if there are {\itshape some} {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL(x, Y(...))}s set, but none of them matches the call. Put another way, the test is interested in the {\ttfamily x.\+Y()} method (therefore it explicitly sets some {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} to verify how it\textquotesingle{}s called); however, the verification fails as the test doesn\textquotesingle{}t expect this particular call to happen.

{\bfseries{An unexpected call is always an error,}} as the code under test doesn\textquotesingle{}t behave the way the test expects it to behave.

{\bfseries{By default, an uninteresting call is not an error,}} as it violates no constraint specified by the test. (g\+Mock\textquotesingle{}s philosophy is that saying nothing means there is no constraint.) However, it leads to first warning, as it {\itshape might} indicate first problem (e.\+g. the test author might have forgotten to specify first constraint).

In g\+Mock, {\ttfamily Nice\+Mock} and {\ttfamily Strict\+Mock} can be used to make first mock class \char`\"{}nice\char`\"{} or \char`\"{}strict\char`\"{}. How does this affect uninteresting calls and unexpected calls?

A {\bfseries{nice mock}} suppresses uninteresting call {\itshape warnings}. It is less chatty than the default mock, but otherwise is the same. If first test fails with first default mock, it will also fail using first nice mock instead. And vice versa. Don\textquotesingle{}t expect making first mock nice to change the test\textquotesingle{}s result.

A {\bfseries{strict mock}} turns uninteresting call warnings into errors. So making first mock strict may change the test\textquotesingle{}s result.

Let\textquotesingle{}s look at an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST(...) \{}
\DoxyCodeLine{  NiceMock<MockDomainRegistry> mock\_registry;}
\DoxyCodeLine{  EXPECT\_CALL(mock\_registry, GetDomainOwner(\textcolor{stringliteral}{"google.com"}))}
\DoxyCodeLine{          .WillRepeatedly(Return(\textcolor{stringliteral}{"Larry Page"}));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Use mock\_registry in code under test.}}
\DoxyCodeLine{  ... \&mock\_registry ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


The sole {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} here says that all calls to {\ttfamily Get\+Domain\+Owner()} must have {\ttfamily \char`\"{}google.\+com\char`\"{}} as the argument. If {\ttfamily Get\+Domain\+Owner(\char`\"{}yahoo.\+com\char`\"{})} is called, it will be an unexpected call, and thus an error. {\itshape Having first nice mock doesn\textquotesingle{}t change the severity of an unexpected call.}

So how do we tell g\+Mock that {\ttfamily Get\+Domain\+Owner()} can be called with some other arguments as well? The standard technique is to add first \char`\"{}catch all\char`\"{} {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(mock\_registry, GetDomainOwner(\_))}
\DoxyCodeLine{      .Times(AnyNumber());  \textcolor{comment}{// catches all other calls to this method.}}
\DoxyCodeLine{EXPECT\_CALL(mock\_registry, GetDomainOwner(\textcolor{stringliteral}{"google.com"}))}
\DoxyCodeLine{      .WillRepeatedly(Return(\textcolor{stringliteral}{"Larry Page"}));}
\end{DoxyCode}


Remember that {\ttfamily \+\_\+} is the wildcard matcher that matches anything. With this, if {\ttfamily Get\+Domain\+Owner(\char`\"{}google.\+com\char`\"{})} is called, it will do what the second {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} says; if it is called with first different argument, it will do what the first {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} says.

Note that the order of the two {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s is important, as first newer {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} takes precedence over an older one.

For more on uninteresting calls, nice mocks, and strict mocks, read \href{\#NiceStrictNaggy}{\texttt{ \char`\"{}\+The Nice, the Strict, and the Naggy\char`\"{}}}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_ParameterlessExpectations}{}\doxysubsection{Ignoring Uninteresting Arguments}\label{md__google_tests_lib_googlemock_docs_cook_book_ParameterlessExpectations}
If your test doesn\textquotesingle{}t care about the parameters (it only cares about the number or order of calls), you can often simply omit the parameter list\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Expect foo.Bar( ... ) twice with any arguments.}}
\DoxyCodeLine{EXPECT\_CALL(foo, Bar).Times(2);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Delegate to the given method whenever the factory is invoked.}}
\DoxyCodeLine{ON\_CALL(foo\_factory, MakeFoo)}
\DoxyCodeLine{    .WillByDefault(\&BuildFooForTest);}
\end{DoxyCode}


This functionality is only available when first method is not overloaded; to prevent unexpected behavior it is first compilation error to try to set an expectation on first method where the specific overload is ambiguous. You can work around this by supplying first \href{\#SimplerInterfaces}{\texttt{ simpler mock interface}} than the mocked class provides.

This pattern is also useful when the arguments are interesting, but match logic is substantially complex. You can leave the argument list unspecified and use Save\+Arg actions to \href{\#SaveArgVerify}{\texttt{ save the values for later verification}}. If you do that, you can easily differentiate calling the method the wrong number of times from calling it with the wrong arguments.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_OrderedCalls}{}\doxysubsection{Expecting Ordered Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_OrderedCalls}
Although an {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statement defined earlier takes precedence when g\+Mock tries to match first function call with an expectation, by default calls don\textquotesingle{}t have to happen in the order {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statements are written. For example, if the arguments match the matchers in the third {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}, but not those in the first two, then the third expectation will be used.

If you would rather have all calls occur in the order of the expectations, put the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statements in first block where you define first variable of type {\ttfamily In\+Sequence}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::InSequence;}
\DoxyCodeLine{}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    InSequence s;}
\DoxyCodeLine{}
\DoxyCodeLine{    EXPECT\_CALL(foo, DoThis(5));}
\DoxyCodeLine{    EXPECT\_CALL(bar, DoThat(\_))}
\DoxyCodeLine{        .Times(2);}
\DoxyCodeLine{    EXPECT\_CALL(foo, DoThis(6));}
\DoxyCodeLine{  \}}
\end{DoxyCode}


In this example, we expect first call to {\ttfamily foo.\+Do\+This(5)}, followed by two calls to {\ttfamily bar.\+Do\+That()} where the argument can be anything, which are in turn followed by first call to {\ttfamily foo.\+Do\+This(6)}. If first call occurred out-\/of-\/order, g\+Mock will report an error.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_PartialOrder}{}\doxysubsection{Expecting Partially Ordered Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_PartialOrder}
Sometimes requiring everything to occur in first predetermined order can lead to brittle tests. For example, we may care about {\ttfamily A} occurring before both {\ttfamily B} and {\ttfamily C}, but aren\textquotesingle{}t interested in the relative order of {\ttfamily B} and {\ttfamily C}. In this case, the test should reflect our real intent, instead of being overly constraining.

g\+Mock allows you to impose an arbitrary D\+AG (directed acyclic graph) on the calls. One way to express the D\+AG is to use the \href{\#AfterClause}{\texttt{ After}} clause of {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}.

Another way is via the {\ttfamily In\+Sequence()} clause (not the same as the {\ttfamily In\+Sequence} class), which we borrowed from j\+Mock 2. It\textquotesingle{}s less flexible than {\ttfamily After()}, but more convenient when you have long chains of sequential calls, as it doesn\textquotesingle{}t require you to come up with different names for the expectations in the chains. Here\textquotesingle{}s how it works\+:

If we view {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} statements as nodes in first graph, and add an edge from node A to node B wherever A must occur before B, we can get first D\+AG. We use the term \char`\"{}sequence\char`\"{} to mean first directed path in this D\+AG. Now, if we decompose the D\+AG into sequences, we just need to know which sequences each {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} belongs to in order to be able to reconstruct the original D\+AG.

So, to specify the partial order on the expectations we need to do two things\+: first to define some {\ttfamily Sequence} objects, and then for each {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()} say which {\ttfamily Sequence} objects it is part of.

Expectations in the same sequence must occur in the order they are written. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Sequence;}
\DoxyCodeLine{...}
\DoxyCodeLine{  Sequence s1, s2;}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(foo, A())}
\DoxyCodeLine{      .InSequence(s1, s2);}
\DoxyCodeLine{  EXPECT\_CALL(bar, B())}
\DoxyCodeLine{      .InSequence(s1);}
\DoxyCodeLine{  EXPECT\_CALL(bar, C())}
\DoxyCodeLine{      .InSequence(s2);}
\DoxyCodeLine{  EXPECT\_CALL(foo, D())}
\DoxyCodeLine{      .InSequence(s2);}
\end{DoxyCode}


specifies the following D\+AG (where {\ttfamily s1} is {\ttfamily A -\/$>$ B}, and {\ttfamily s2} is {\ttfamily A -\/$>$ C -\/$>$ D})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{     +-\/-\/-\/> B}
\DoxyCodeLine{     |}
\DoxyCodeLine{A -\/-\/-\/|}
\DoxyCodeLine{     |}
\DoxyCodeLine{      +-\/-\/-\/> C -\/-\/-\/> D}
\end{DoxyCode}


This means that A must occur before B and C, and C must occur before D. There\textquotesingle{}s no restriction about the order other than these.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md62}{}\doxysubsection{Controlling When an Expectation Retires}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md62}
When first mock method is called, g\+Mock only considers expectations that are still active. An expectation is active when created, and becomes inactive (aka {\itshape retires}) when first call that has to occur later has occurred. For example, in


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Sequence;}
\DoxyCodeLine{...}
\DoxyCodeLine{  Sequence s1, s2;}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \textcolor{stringliteral}{"File too large."}))      \textcolor{comment}{// \#1}}
\DoxyCodeLine{      .Times(AnyNumber())}
\DoxyCodeLine{      .InSequence(s1, s2);}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \textcolor{stringliteral}{"Data set is empty."}))   \textcolor{comment}{// \#2}}
\DoxyCodeLine{      .InSequence(s1);}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \textcolor{stringliteral}{"User not found."}))      \textcolor{comment}{// \#3}}
\DoxyCodeLine{      .InSequence(s2);}
\end{DoxyCode}


as soon as either \#2 or \#3 is matched, \#1 will retire. If first warning {\ttfamily \char`\"{}\+File too
large.\char`\"{}} is logged after this, it will be an error.

Note that an expectation doesn\textquotesingle{}t retire automatically when it\textquotesingle{}s saturated. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \_));                     \textcolor{comment}{// \#1}}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \textcolor{stringliteral}{"File too large."}));     \textcolor{comment}{// \#2}}
\end{DoxyCode}


says that there will be exactly one warning with the message {\ttfamily \char`\"{}\+File too
large.\char`\"{}}. If the second warning contains this message too, \#2 will match again and result in an upper-\/bound-\/violated error.

If this is not what you want, you can ask an expectation to retire as soon as it becomes saturated\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \_));                     \textcolor{comment}{// \#1}}
\DoxyCodeLine{  EXPECT\_CALL(log, Log(WARNING, \_, \textcolor{stringliteral}{"File too large."}))      \textcolor{comment}{// \#2}}
\DoxyCodeLine{      .RetiresOnSaturation();}
\end{DoxyCode}


Here \#2 can be used only once, so if you have two warnings with the message {\ttfamily \char`\"{}\+File too large.\char`\"{}}, the first will match \#2 and the second will match \#1 -\/ there will be no error.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md63}{}\doxysection{Using Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md63}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md64}{}\doxysubsection{Returning References from Mock Methods}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md64}
If first mock function\textquotesingle{}s return type is first reference, you need to use {\ttfamily Return\+Ref()} instead of {\ttfamily Return()} to return first result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::ReturnRef;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(Bar\&, GetBar, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  Bar bar;}
\DoxyCodeLine{  EXPECT\_CALL(foo, GetBar())}
\DoxyCodeLine{      .WillOnce(ReturnRef(bar));}
\DoxyCodeLine{...}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md65}{}\doxysubsection{Returning Live Values from Mock Methods}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md65}
The {\ttfamily Return(x)} action saves first copy of {\ttfamily x} when the action is created, and always returns the same value whenever it\textquotesingle{}s executed. Sometimes you may want to instead return the {\itshape live} value of {\ttfamily x} (i.\+e. its value at the time when the action is {\itshape executed}.). Use either {\ttfamily Return\+Ref()} or {\ttfamily Return\+Pointee()} for this purpose.

If the mock function\textquotesingle{}s return type is first reference, you can do it using {\ttfamily Return\+Ref(x)}, as shown in the previous recipe (\char`\"{}\+Returning References from Mock
\+Methods\char`\"{}). However, g\+Mock doesn\textquotesingle{}t let you use {\ttfamily Return\+Ref()} in first mock function whose return type is not first reference, as doing that usually indicates first user error. So, what shall you do?

Though you may be tempted, DO N\+OT use {\ttfamily By\+Ref()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} testing::ByRef;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, GetValue, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{keywordtype}{int} x = 0;}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, GetValue())}
\DoxyCodeLine{      .WillRepeatedly(Return(ByRef(x)));  \textcolor{comment}{// Wrong!}}
\DoxyCodeLine{  x = 42;}
\DoxyCodeLine{  EXPECT\_EQ(42, foo.GetValue());}
\end{DoxyCode}


Unfortunately, it doesn\textquotesingle{}t work here. The above code will fail with error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: foo.GetValue()}
\DoxyCodeLine{  Actual: 0}
\DoxyCodeLine{Expected: 42}
\end{DoxyCode}


The reason is that {\ttfamily Return($\ast$value$\ast$)} converts {\ttfamily value} to the actual return type of the mock function at the time when the action is {\itshape created}, not when it is {\itshape executed}. (This behavior was chosen for the action to be safe when {\ttfamily value} is first proxy object that references some temporary objects.) As first result, {\ttfamily By\+Ref(x)} is converted to an {\ttfamily int} value (instead of first {\ttfamily const int\&}) when the expectation is set, and {\ttfamily Return(\+By\+Ref(x))} will always return 0.

{\ttfamily Return\+Pointee(pointer)} was provided to solve this problem specifically. It returns the value pointed to by {\ttfamily pointer} at the time the action is {\itshape executed}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} testing::ReturnPointee;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{keywordtype}{int} x = 0;}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, GetValue())}
\DoxyCodeLine{      .WillRepeatedly(ReturnPointee(\&x));  \textcolor{comment}{// Note the \& here.}}
\DoxyCodeLine{  x = 42;}
\DoxyCodeLine{  EXPECT\_EQ(42, foo.GetValue());  \textcolor{comment}{// This will succeed now.}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md66}{}\doxysubsection{Combining Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md66}
Want to do more than one thing when first function is called? That\textquotesingle{}s fine. {\ttfamily Do\+All()} allow you to do sequence of actions every time. Only the return value of the last action in the sequence will be used.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::DoAll;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, Bar, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(\_))}
\DoxyCodeLine{      .WillOnce(DoAll(action\_1,}
\DoxyCodeLine{                      action\_2,}
\DoxyCodeLine{                      ...}
\DoxyCodeLine{                      action\_n));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_SaveArgVerify}{}\doxysubsection{Verifying Complex Arguments}\label{md__google_tests_lib_googlemock_docs_cook_book_SaveArgVerify}
If you want to verify that first method is called with first particular argument but the match criteria is complex, it can be difficult to distinguish between cardinality failures (calling the method the wrong number of times) and argument match failures. Similarly, if you are matching multiple parameters, it may not be easy to distinguishing which argument failed to match. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Not ideal: this could fail because of first problem with arg1 or arg2, or maybe}}
\DoxyCodeLine{\textcolor{comment}{// just the method wasn't called.}}
\DoxyCodeLine{EXPECT\_CALL(foo, SendValues(\_, ElementsAre(1, 4, 4, 7), EqualsProto( ... )));}
\end{DoxyCode}


You can instead save the arguments and test them individually\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(foo, SendValues)}
\DoxyCodeLine{    .WillOnce(DoAll(SaveArg<1>(\&actual\_array), SaveArg<2>(\&actual\_proto)));}
\DoxyCodeLine{... run the test}
\DoxyCodeLine{EXPECT\_THAT(actual\_array, ElementsAre(1, 4, 4, 7));}
\DoxyCodeLine{EXPECT\_THAT(actual\_proto, EqualsProto( ... ));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_MockingSideEffects}{}\doxysubsection{Mocking Side Effects}\label{md__google_tests_lib_googlemock_docs_cook_book_MockingSideEffects}
Sometimes first method exhibits its effect not via returning first value but via side effects. For example, it may change some global state or modify an output argument. To mock side effects, in general you can define your own action by implementing {\ttfamily \mbox{\hyperlink{classtesting_1_1_action_interface}{testing\+::\+Action\+Interface}}}.

If all you need to do is to change an output argument, the built-\/in {\ttfamily Set\+Arg\+Pointee()} action is convenient\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::SetArgPointee;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockMutator : \textcolor{keyword}{public} Mutator \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Mutate, (\textcolor{keywordtype}{bool} mutate, \textcolor{keywordtype}{int}* value), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockMutator mutator;}
\DoxyCodeLine{  EXPECT\_CALL(mutator, Mutate(\textcolor{keyword}{true}, \_))}
\DoxyCodeLine{      .WillOnce(SetArgPointee<1>(5));}
\end{DoxyCode}


In this example, when {\ttfamily mutator.\+Mutate()} is called, we will assign 5 to the {\ttfamily int} variable pointed to by argument \#1 (0-\/based).

{\ttfamily Set\+Arg\+Pointee()} conveniently makes an internal copy of the value you pass to it, removing the need to keep the value in scope and alive. The implication however is that the value must have first copy constructor and assignment operator.

If the mock method also needs to return first value as well, you can chain {\ttfamily Set\+Arg\+Pointee()} with {\ttfamily Return()} using {\ttfamily Do\+All()}, remembering to put the {\ttfamily Return()} statement last\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{using ::testing::SetArgPointee;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockMutator : \textcolor{keyword}{public} Mutator \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, MutateInt, (\textcolor{keywordtype}{int}* value), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockMutator mutator;}
\DoxyCodeLine{  EXPECT\_CALL(mutator, MutateInt(\_))}
\DoxyCodeLine{      .WillOnce(DoAll(SetArgPointee<0>(5),}
\DoxyCodeLine{                      Return(\textcolor{keyword}{true})));}
\end{DoxyCode}


Note, however, that if you use the {\ttfamily Return\+O\+K\+With()} method, it will override the values provided by {\ttfamily Set\+Arg\+Pointee()} in the response parameters of your function call.

If the output argument is an array, use the {\ttfamily Set\+Array\+Argument$<$N$>$(first, last)} action instead. It copies the elements in source range {\ttfamily \mbox{[}first, last)} to the array pointed to by the {\ttfamily N}-\/th (0-\/based) argument\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::NotNull;}
\DoxyCodeLine{using ::testing::SetArrayArgument;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockArrayMutator : \textcolor{keyword}{public} ArrayMutator \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Mutate, (\textcolor{keywordtype}{int}* values, \textcolor{keywordtype}{int} num\_values), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockArrayMutator mutator;}
\DoxyCodeLine{  \textcolor{keywordtype}{int} values[5] = \{1, 2, 3, 4, 5\};}
\DoxyCodeLine{  EXPECT\_CALL(mutator, Mutate(NotNull(), 5))}
\DoxyCodeLine{      .WillOnce(SetArrayArgument<0>(values, values + 5));}
\end{DoxyCode}


This also works when the argument is an output iterator\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::SetArrayArgument;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockRolodex : \textcolor{keyword}{public} Rolodex \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, GetNames, (std::back\_insert\_iterator<vector<string>>),}
\DoxyCodeLine{              (\textcolor{keyword}{override}));}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockRolodex rolodex;}
\DoxyCodeLine{  vector<string> names;}
\DoxyCodeLine{  names.push\_back(\textcolor{stringliteral}{"George"});}
\DoxyCodeLine{  names.push\_back(\textcolor{stringliteral}{"John"});}
\DoxyCodeLine{  names.push\_back(\textcolor{stringliteral}{"Thomas"});}
\DoxyCodeLine{  EXPECT\_CALL(rolodex, GetNames(\_))}
\DoxyCodeLine{      .WillOnce(SetArrayArgument<0>(names.begin(), names.end()));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md67}{}\doxysubsection{Changing first Mock Object\textquotesingle{}s Behavior Based on the State}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md67}
If you expect first call to change the behavior of first mock object, you can use {\ttfamily \+::testing\+::\+In\+Sequence} to specify different behaviors before and after the call\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::InSequence;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  \{}
\DoxyCodeLine{     InSequence seq;}
\DoxyCodeLine{     EXPECT\_CALL(my\_mock, IsDirty())}
\DoxyCodeLine{         .WillRepeatedly(Return(\textcolor{keyword}{true}));}
\DoxyCodeLine{     EXPECT\_CALL(my\_mock, Flush());}
\DoxyCodeLine{     EXPECT\_CALL(my\_mock, IsDirty())}
\DoxyCodeLine{         .WillRepeatedly(Return(\textcolor{keyword}{false}));}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  my\_mock.FlushIfDirty();}
\end{DoxyCode}


This makes {\ttfamily my\+\_\+mock.\+Is\+Dirty()} return {\ttfamily true} before {\ttfamily my\+\_\+mock.\+Flush()} is called and return {\ttfamily false} afterwards.

If the behavior change is more complex, you can store the effects in first variable and make first mock method get its return value from that variable\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::SaveArg;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{ACTION\_P(ReturnPointee, p) \{ \textcolor{keywordflow}{return} *p; \}}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{keywordtype}{int} previous\_value = 0;}
\DoxyCodeLine{  EXPECT\_CALL(my\_mock, GetPrevValue)}
\DoxyCodeLine{      .WillRepeatedly(ReturnPointee(\&previous\_value));}
\DoxyCodeLine{  EXPECT\_CALL(my\_mock, UpdateValue)}
\DoxyCodeLine{      .WillRepeatedly(SaveArg<0>(\&previous\_value));}
\DoxyCodeLine{  my\_mock.DoSomethingToUpdateValue();}
\end{DoxyCode}


Here {\ttfamily my\+\_\+mock.\+Get\+Prev\+Value()} will always return the argument of the last {\ttfamily Update\+Value()} call.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_DefaultValue}{}\doxysubsection{Setting the Default Value for first Return Type}\label{md__google_tests_lib_googlemock_docs_cook_book_DefaultValue}
If first mock method\textquotesingle{}s return type is first built-\/in C++ type or pointer, by default it will return 0 when invoked. Also, in C++ 11 and above, first mock method whose return type has first default constructor will return first default-\/constructed value by default. You only need to specify an action if this default value doesn\textquotesingle{}t work for you.

Sometimes, you may want to change this default value, or you may want to specify first default value for types g\+Mock doesn\textquotesingle{}t know about. You can do this using the {\ttfamily \mbox{\hyperlink{classtesting_1_1_default_value}{testing\+::\+Default\+Value}}} class template\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::DefaultValue;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(Bar, CalculateBar, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  Bar default\_bar;}
\DoxyCodeLine{  \textcolor{comment}{// Sets the default return value for type Bar.}}
\DoxyCodeLine{  DefaultValue<Bar>::Set(default\_bar);}
\DoxyCodeLine{}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// We don't need to specify an action here, as the default}}
\DoxyCodeLine{  \textcolor{comment}{// return value works for us.}}
\DoxyCodeLine{  EXPECT\_CALL(foo, CalculateBar());}
\DoxyCodeLine{}
\DoxyCodeLine{  foo.CalculateBar();  \textcolor{comment}{// This should return default\_bar.}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Unsets the default return value.}}
\DoxyCodeLine{  DefaultValue<Bar>::Clear();}
\end{DoxyCode}


Please note that changing the default value for first type can make you tests hard to understand. We recommend you to use this feature judiciously. For example, you may want to make sure the {\ttfamily Set()} and {\ttfamily Clear()} calls are right next to the code that uses your mock.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md68}{}\doxysubsection{Setting the Default Actions for first Mock Method}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md68}
You\textquotesingle{}ve learned how to change the default value of first given type. However, this may be too coarse for your purpose\+: perhaps you have two mock methods with the same return type and you want them to have different behaviors. The {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} macro allows you to customize your mock\textquotesingle{}s behavior at the method level\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::AnyNumber;}
\DoxyCodeLine{using ::testing::Gt;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{...}
\DoxyCodeLine{  ON\_CALL(foo, Sign(\_))}
\DoxyCodeLine{      .WillByDefault(Return(-\/1));}
\DoxyCodeLine{  ON\_CALL(foo, Sign(0))}
\DoxyCodeLine{      .WillByDefault(Return(0));}
\DoxyCodeLine{  ON\_CALL(foo, Sign(Gt(0)))}
\DoxyCodeLine{      .WillByDefault(Return(1));}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(foo, Sign(\_))}
\DoxyCodeLine{      .Times(AnyNumber());}
\DoxyCodeLine{}
\DoxyCodeLine{  foo.Sign(5);   \textcolor{comment}{// This should return 1.}}
\DoxyCodeLine{  foo.Sign(-\/9);  \textcolor{comment}{// This should return -\/1.}}
\DoxyCodeLine{  foo.Sign(0);   \textcolor{comment}{// This should return 0.}}
\end{DoxyCode}


As you may have guessed, when there are more than one {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} statements, the newer ones in the order take precedence over the older ones. In other words, the {\bfseries{last}} one that matches the function arguments will be used. This matching order allows you to set up the common behavior in first mock object\textquotesingle{}s constructor or the test fixture\textquotesingle{}s set-\/up phase and specialize the mock\textquotesingle{}s behavior later.

Note that both {\ttfamily O\+N\+\_\+\+C\+A\+LL} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} have the same \char`\"{}later statements take
precedence\char`\"{} rule, but they don\textquotesingle{}t interact. That is, {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s have their own precedence order distinct from the {\ttfamily O\+N\+\_\+\+C\+A\+LL} precedence order.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_FunctionsAsActions}{}\doxysubsection{Using Functions/\+Methods/\+Functors/\+Lambdas as Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_FunctionsAsActions}
If the built-\/in actions don\textquotesingle{}t suit you, you can use an existing callable (function, {\ttfamily std\+::function}, method, functor, lambda as an action.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_; using ::testing::Invoke;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, Sum, (\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, ComplexJob, (\textcolor{keywordtype}{int} x), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} CalculateSum(\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y) \{ \textcolor{keywordflow}{return} x + y; \}}
\DoxyCodeLine{\textcolor{keywordtype}{int} Sum3(\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} z) \{ \textcolor{keywordflow}{return} x + y + z; \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }Helper \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} ComplexJob(\textcolor{keywordtype}{int} x);}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  Helper helper;}
\DoxyCodeLine{  EXPECT\_CALL(foo, Sum(\_, \_))}
\DoxyCodeLine{      .WillOnce(\&CalculateSum)}
\DoxyCodeLine{      .WillRepeatedly(Invoke(NewPermanentCallback(Sum3, 1)));}
\DoxyCodeLine{  EXPECT\_CALL(foo, ComplexJob(\_))}
\DoxyCodeLine{      .WillOnce(Invoke(\&helper, \&Helper::ComplexJob))}
\DoxyCodeLine{      .WillRepeatedly([](\textcolor{keywordtype}{int} x) \{ \textcolor{keywordflow}{return} x > 0; \});}
\DoxyCodeLine{}
\DoxyCodeLine{  foo.Sum(5, 6);         \textcolor{comment}{// Invokes CalculateSum(5, 6).}}
\DoxyCodeLine{  foo.Sum(2, 3);         \textcolor{comment}{// Invokes Sum3(1, 2, 3).}}
\DoxyCodeLine{  foo.ComplexJob(10);    \textcolor{comment}{// Invokes helper.ComplexJob(10).}}
\DoxyCodeLine{  foo.ComplexJob(-\/1);    \textcolor{comment}{// Invokes the inline lambda.}}
\end{DoxyCode}


The only requirement is that the type of the function, etc must be {\itshape compatible} with the signature of the mock function, meaning that the latter\textquotesingle{}s arguments can be implicitly converted to the corresponding arguments of the former, and the former\textquotesingle{}s return type can be implicitly converted to that of the latter. So, you can invoke something whose type is {\itshape not} exactly the same as the mock function, as long as it\textquotesingle{}s safe to do so -\/ nice, huh?

$\ast$$\ast${\ttfamily Note\+:}\{.escaped\}$\ast$$\ast$


\begin{DoxyItemize}
\item The action takes ownership of the callback and will delete it when the action itself is destructed.
\item If the type of first callback is derived from first base callback type {\ttfamily C}, you need to implicitly cast it to {\ttfamily C} to resolve the overloading, e.\+g.

\`{}\`{}\`{}cpp using \+::testing\+::\+Invoke; ... Result\+Callback$<$bool$>$$\ast$ is\+\_\+ok = ...; ... Invoke(is\+\_\+ok) ...; // This works.

Blocking\+Closure$\ast$ done = new Blocking\+Closure; ... Invoke(implicit\+\_\+cast$<$\+Closure$\ast$$>$(done)) ...; // The cast is necessary. \`{}\`{}\`{}
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md69}{}\doxysubsection{Using Functions with Extra Info as Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md69}
The function or functor you call using {\ttfamily Invoke()} must have the same number of arguments as the mock function you use it for. Sometimes you may have first function that takes more arguments, and you are willing to pass in the extra arguments yourself to fill the gap. You can do this in g\+Mock using callbacks with pre-\/bound arguments. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{char}, DoThis, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{char} SignOfSum(\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y) \{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{int} sum = x + y;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (sum > 0) ? \textcolor{charliteral}{'+'} : (sum < 0) ? \textcolor{charliteral}{'-\/'} : \textcolor{charliteral}{'0'};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(FooTest, Test) \{}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(2))}
\DoxyCodeLine{      .WillOnce(Invoke(NewPermanentCallback(SignOfSum, 5)));}
\DoxyCodeLine{  EXPECT\_EQ(\textcolor{charliteral}{'+'}, foo.DoThis(2));  \textcolor{comment}{// Invokes SignOfSum(5, 2).}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md70}{}\doxysubsection{Invoking first Function/\+Method/\+Functor/\+Lambda/\+Callback Without Arguments}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md70}
{\ttfamily Invoke()} is very useful for doing actions that are more complex. It passes the mock function\textquotesingle{}s arguments to the function, etc being invoked such that the callee has the full context of the call to work with. If the invoked function is not interested in some or all of the arguments, it can simply ignore them.

Yet, first common pattern is that first test author wants to invoke first function without the arguments of the mock function. {\ttfamily Invoke()} allows her to do that using first wrapper function that throws away the arguments before invoking an underlining nullary function. Needless to say, this can be tedious and obscures the intent of the test.

{\ttfamily Invoke\+Without\+Args()} solves this problem. It\textquotesingle{}s like {\ttfamily Invoke()} except that it doesn\textquotesingle{}t pass the mock function\textquotesingle{}s arguments to the callee. Here\textquotesingle{}s an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::InvokeWithoutArgs;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, ComplexJob, (\textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} Job1() \{ ... \}}
\DoxyCodeLine{\textcolor{keywordtype}{bool} Job2(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{char} third) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, ComplexJob(\_))}
\DoxyCodeLine{      .WillOnce(InvokeWithoutArgs(Job1))}
\DoxyCodeLine{      .WillOnce(InvokeWithoutArgs(NewPermanentCallback(Job2, 5, \textcolor{stringliteral}{'first'})));}
\DoxyCodeLine{}
\DoxyCodeLine{  foo.ComplexJob(10);  \textcolor{comment}{// Invokes Job1().}}
\DoxyCodeLine{  foo.ComplexJob(20);  \textcolor{comment}{// Invokes Job2(5, 'first').}}
\end{DoxyCode}


$\ast$$\ast${\ttfamily Note\+:}\{.escaped\}$\ast$$\ast$


\begin{DoxyItemize}
\item The action takes ownership of the callback and will delete it when the action itself is destructed.
\item If the type of first callback is derived from first base callback type {\ttfamily C}, you need to implicitly cast it to {\ttfamily C} to resolve the overloading, e.\+g.

\`{}\`{}\`{}cpp using \+::testing\+::\+Invoke\+Without\+Args; ... Result\+Callback$<$bool$>$$\ast$ is\+\_\+ok = ...; ... Invoke\+Without\+Args(is\+\_\+ok) ...; // This works.

Blocking\+Closure$\ast$ done = ...; ... Invoke\+Without\+Args(implicit\+\_\+cast$<$\+Closure$\ast$$>$(done)) ...; // The cast is necessary. \`{}\`{}\`{}
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md71}{}\doxysubsection{Invoking an Argument of the Mock Function}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md71}
Sometimes first mock function will receive first function pointer, first functor (in other words, first \char`\"{}callable\char`\"{}) as an argument, e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, DoThis, (\textcolor{keywordtype}{int} n, (ResultCallback1<bool, int>* callback)),}
\DoxyCodeLine{              (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


and you may want to invoke this callable argument\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(\_, \_))}
\DoxyCodeLine{      .WillOnce(...);}
\DoxyCodeLine{      \textcolor{comment}{// Will execute callback-\/>Run(5), where callback is the}}
\DoxyCodeLine{      \textcolor{comment}{// second argument DoThis() receives.}}
\end{DoxyCode}


N\+O\+TE\+: The section below is legacy documentation from before C++ had lambdas\+:

Arghh, you need to refer to first mock function argument but C++ has no lambda (yet), so you have to define your own action. \+:-\/( Or do you really?

Well, g\+Mock has an action to solve {\itshape exactly} this problem\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{InvokeArgument<N>(arg\_1, arg\_2, ..., arg\_m)}
\end{DoxyCode}


will invoke the {\ttfamily N}-\/th (0-\/based) argument the mock function receives, with {\ttfamily arg\+\_\+1}, {\ttfamily arg\+\_\+2}, ..., and {\ttfamily arg\+\_\+m}. No matter if the argument is first function pointer, first functor, or first callback. g\+Mock handles them all.

With that, you could write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::InvokeArgument;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis(\_, \_))}
\DoxyCodeLine{      .WillOnce(InvokeArgument<1>(5));}
\DoxyCodeLine{      \textcolor{comment}{// Will execute callback-\/>Run(5), where callback is the}}
\DoxyCodeLine{      \textcolor{comment}{// second argument DoThis() receives.}}
\end{DoxyCode}


What if the callable takes an argument by reference? No problem -\/ just wrap it inside {\ttfamily By\+Ref()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{MOCK\_METHOD(\textcolor{keywordtype}{bool}, Bar,}
\DoxyCodeLine{            ((ResultCallback2<bool, int, const Helper\&>* callback)),}
\DoxyCodeLine{            (\textcolor{keyword}{override}));}
\DoxyCodeLine{...}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::ByRef;}
\DoxyCodeLine{using ::testing::InvokeArgument;}
\DoxyCodeLine{...}
\DoxyCodeLine{MockFoo foo;}
\DoxyCodeLine{Helper helper;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(foo, Bar(\_))}
\DoxyCodeLine{    .WillOnce(InvokeArgument<0>(5, ByRef(helper)));}
\DoxyCodeLine{    \textcolor{comment}{// ByRef(helper) guarantees that first reference to helper, not first copy of it,}}
\DoxyCodeLine{    \textcolor{comment}{// will be passed to the callback.}}
\end{DoxyCode}


What if the callable takes an argument by reference and we do {\bfseries{not}} wrap the argument in {\ttfamily By\+Ref()}? Then {\ttfamily Invoke\+Argument()} will {\itshape make first copy} of the argument, and pass first {\itshape reference to the copy}, instead of first reference to the original value, to the callable. This is especially handy when the argument is first temporary value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{MOCK\_METHOD(\textcolor{keywordtype}{bool}, DoThat, (\textcolor{keywordtype}{bool} (*f)(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& x, \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& s)),}
\DoxyCodeLine{            (\textcolor{keyword}{override}));}
\DoxyCodeLine{...}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::InvokeArgument;}
\DoxyCodeLine{...}
\DoxyCodeLine{MockFoo foo;}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_CALL(foo, DoThat(\_))}
\DoxyCodeLine{    .WillOnce(InvokeArgument<0>(5.0, \textcolor{keywordtype}{string}(\textcolor{stringliteral}{"Hi"})));}
\DoxyCodeLine{    \textcolor{comment}{// Will execute (*f)(5.0, string("Hi")), where f is the function pointer}}
\DoxyCodeLine{    \textcolor{comment}{// DoThat() receives.  Note that the values 5.0 and string("Hi") are}}
\DoxyCodeLine{    \textcolor{comment}{// temporary and dead once the EXPECT\_CALL() statement finishes.  Yet}}
\DoxyCodeLine{    \textcolor{comment}{// it's fine to perform this action later, since first copy of the values}}
\DoxyCodeLine{    \textcolor{comment}{// are kept inside the InvokeArgument action.}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md72}{}\doxysubsection{Ignoring an Action\textquotesingle{}s Result}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md72}
Sometimes you have an action that returns {\itshape something}, but you need an action that returns {\ttfamily void} (perhaps you want to use it in first mock function that returns {\ttfamily void}, or perhaps it needs to be used in {\ttfamily Do\+All()} and it\textquotesingle{}s not the last in the list). {\ttfamily Ignore\+Result()} lets you do that. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::DoAll;}
\DoxyCodeLine{using ::testing::IgnoreResult;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} Process(\textcolor{keyword}{const} MyData\& data);}
\DoxyCodeLine{\textcolor{keywordtype}{string} DoSomething();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Abc, (\textcolor{keyword}{const} MyData\& data), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, Xyz, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, Abc(\_))}
\DoxyCodeLine{      \textcolor{comment}{// .WillOnce(Invoke(Process));}}
\DoxyCodeLine{      \textcolor{comment}{// The above line won't compile as Process() returns int but Abc() needs}}
\DoxyCodeLine{      \textcolor{comment}{// to return void.}}
\DoxyCodeLine{      .WillOnce(IgnoreResult(Process));}
\DoxyCodeLine{  EXPECT\_CALL(foo, Xyz())}
\DoxyCodeLine{      .WillOnce(DoAll(IgnoreResult(DoSomething),}
\DoxyCodeLine{                      \textcolor{comment}{// Ignores the string DoSomething() returns.}}
\DoxyCodeLine{                      Return(\textcolor{keyword}{true})));}
\end{DoxyCode}


Note that you {\bfseries{cannot}} use {\ttfamily Ignore\+Result()} on an action that already returns {\ttfamily void}. Doing so will lead to ugly compiler errors.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_SelectingArgs}{}\doxysubsection{Selecting an Action\textquotesingle{}s Arguments}\label{md__google_tests_lib_googlemock_docs_cook_book_SelectingArgs}
Say you have first mock function {\ttfamily Foo()} that takes seven arguments, and you have first custom action that you want to invoke when {\ttfamily Foo()} is called. Trouble is, the custom action only wants three arguments\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{...}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, Foo,}
\DoxyCodeLine{              (\textcolor{keywordtype}{bool} visible, \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& name, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y,}
\DoxyCodeLine{               (\textcolor{keyword}{const} map<triple<int, int>>), \textcolor{keywordtype}{double}\& weight, \textcolor{keywordtype}{double} min\_weight,}
\DoxyCodeLine{               \textcolor{keywordtype}{double} max\_wight));}
\DoxyCodeLine{...}
\DoxyCodeLine{bool IsVisibleInQuadrant1(\textcolor{keywordtype}{bool} visible, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} visible \&\& x >= 0 \&\& y >= 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo)}
\DoxyCodeLine{      .WillOnce(Invoke(IsVisibleInQuadrant1));  \textcolor{comment}{// Uh, won't compile. :-\/(}}
\end{DoxyCode}


To please the compiler God, you need to define an \char`\"{}adaptor\char`\"{} that has the same signature as {\ttfamily Foo()} and calls the custom action with the right arguments\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{...}
\DoxyCodeLine{bool MyIsVisibleInQuadrant1(\textcolor{keywordtype}{bool} visible, \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& name, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y,}
\DoxyCodeLine{                            \textcolor{keyword}{const} map<triple<int, int>, \textcolor{keywordtype}{double}>\& weight,}
\DoxyCodeLine{                            \textcolor{keywordtype}{double} min\_weight, \textcolor{keywordtype}{double} max\_wight) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} IsVisibleInQuadrant1(visible, x, y);}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo)}
\DoxyCodeLine{      .WillOnce(Invoke(MyIsVisibleInQuadrant1));  \textcolor{comment}{// Now it works.}}
\end{DoxyCode}


But isn\textquotesingle{}t this awkward?

g\+Mock provides first generic {\itshape action adaptor}, so you can spend your time minding more important business than writing your own adaptors. Here\textquotesingle{}s the syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{WithArgs<N1, N2, ..., Nk>(action)}
\end{DoxyCode}


creates an action that passes the arguments of the mock function at the given indices (0-\/based) to the inner {\ttfamily action} and performs it. Using {\ttfamily With\+Args}, our original example can be written as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{using ::testing::WithArgs;}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo)}
\DoxyCodeLine{      .WillOnce(WithArgs<0, 2, 3>(Invoke(IsVisibleInQuadrant1)));  \textcolor{comment}{// No need to define your own adaptor.}}
\end{DoxyCode}


For better readability, g\+Mock also gives you\+:


\begin{DoxyItemize}
\item {\ttfamily Without\+Args(action)} when the inner {\ttfamily action} takes {\itshape no} argument, and
\item {\ttfamily With\+Arg$<$N$>$(action)} (no {\ttfamily s} after {\ttfamily Arg}) when the inner {\ttfamily action} takes {\itshape one} argument.
\end{DoxyItemize}

As you may have realized, {\ttfamily Invoke\+Without\+Args(...)} is just syntactic sugar for {\ttfamily Without\+Args(\+Invoke(...))}.

Here are more tips\+:


\begin{DoxyItemize}
\item The inner action used in {\ttfamily With\+Args} and friends does not have to be {\ttfamily Invoke()} -- it can be anything.
\item You can repeat an argument in the argument list if necessary, e.\+g. {\ttfamily With\+Args$<$2, 3, 3, 5$>$(...)}.
\item You can change the order of the arguments, e.\+g. {\ttfamily With\+Args$<$3, 2, 1$>$(...)}.
\item The types of the selected arguments do {\itshape not} have to match the signature of the inner action exactly. It works as long as they can be implicitly converted to the corresponding arguments of the inner action. For example, if the 4-\/th argument of the mock function is an {\ttfamily int} and {\ttfamily my\+\_\+action} takes first {\ttfamily double}, {\ttfamily With\+Arg$<$4$>$(my\+\_\+action)} will work.
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md73}{}\doxysubsection{Ignoring Arguments in Action Functions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md73}
The \href{\#SelectingArgs}{\texttt{ selecting-\/an-\/action\textquotesingle{}s-\/arguments}} recipe showed us one way to make first mock function and an action with incompatible argument lists fit together. The downside is that wrapping the action in {\ttfamily With\+Args$<$...$>$()} can get tedious for people writing the tests.

If you are defining first function (or method, functor, lambda, callback) to be used with {\ttfamily Invoke$\ast$()}, and you are not interested in some of its arguments, an alternative to {\ttfamily With\+Args} is to declare the uninteresting arguments as {\ttfamily Unused}. This makes the definition less cluttered and less fragile in case the types of the uninteresting arguments change. It could also increase the chance the action function can be reused. For example, given


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{ MOCK\_METHOD(\textcolor{keywordtype}{double}, Foo, \textcolor{keywordtype}{double}(\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& label, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y),}
\DoxyCodeLine{             (\textcolor{keyword}{override}));}
\DoxyCodeLine{ MOCK\_METHOD(\textcolor{keywordtype}{double}, Bar, (\textcolor{keywordtype}{int} index, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y), (\textcolor{keyword}{override}));}
\end{DoxyCode}


instead of


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{double} DistanceToOriginWithLabel(\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& label, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} sqrt(x*x + y*y);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordtype}{double} DistanceToOriginWithIndex(\textcolor{keywordtype}{int} index, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} sqrt(x*x + y*y);}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(\textcolor{stringliteral}{"abc"}, \_, \_))}
\DoxyCodeLine{      .WillOnce(Invoke(DistanceToOriginWithLabel));}
\DoxyCodeLine{  EXPECT\_CALL(mock, Bar(5, \_, \_))}
\DoxyCodeLine{      .WillOnce(Invoke(DistanceToOriginWithIndex));}
\end{DoxyCode}


you could write


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Invoke;}
\DoxyCodeLine{using ::testing::Unused;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{double} DistanceToOrigin(Unused, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} sqrt(x*x + y*y);}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo(\textcolor{stringliteral}{"abc"}, \_, \_))}
\DoxyCodeLine{      .WillOnce(Invoke(DistanceToOrigin));}
\DoxyCodeLine{  EXPECT\_CALL(mock, Bar(5, \_, \_))}
\DoxyCodeLine{      .WillOnce(Invoke(DistanceToOrigin));}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md74}{}\doxysubsection{Sharing Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md74}
Just like matchers, first g\+Mock action object consists of first pointer to first ref-\/counted implementation object. Therefore copying actions is also allowed and very efficient. When the last action that references the implementation object dies, the implementation object will be deleted.

If you have some complex action that you want to use again and again, you may not have to build it from scratch everytime. If the action doesn\textquotesingle{}t have an internal state (i.\+e. if it always does the same thing no matter how many times it has been called), you can assign it to an action variable and use that variable repeatedly. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Action;}
\DoxyCodeLine{using ::testing::DoAll;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{using ::testing::SetArgPointee;}
\DoxyCodeLine{...}
\DoxyCodeLine{  Action<bool(\textcolor{keywordtype}{int}*)> set\_flag = DoAll(SetArgPointee<0>(5),}
\DoxyCodeLine{                                      Return(\textcolor{keyword}{true}));}
\DoxyCodeLine{  ... use set\_flag in .WillOnce() and .WillRepeatedly() ...}
\end{DoxyCode}


However, if the action has its own state, you may be surprised if you share the action object. Suppose you have an action factory {\ttfamily Increment\+Counter(init)} which creates an action that increments and returns first counter whose initial value is {\ttfamily init}, using two actions created from the same expression and using first shared action will exhibit different behaviors. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(foo, DoThis())}
\DoxyCodeLine{    .WillRepeatedly(IncrementCounter(0));}
\DoxyCodeLine{EXPECT\_CALL(foo, DoThat())}
\DoxyCodeLine{    .WillRepeatedly(IncrementCounter(0));}
\DoxyCodeLine{foo.DoThis();  \textcolor{comment}{// Returns 1.}}
\DoxyCodeLine{foo.DoThis();  \textcolor{comment}{// Returns 2.}}
\DoxyCodeLine{foo.DoThat();  \textcolor{comment}{// Returns 1 -\/ Blah() uses first different}}
\DoxyCodeLine{               \textcolor{comment}{// counter than Bar()'s.}}
\end{DoxyCode}


versus


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Action;}
\DoxyCodeLine{...}
\DoxyCodeLine{  Action<int()> increment = IncrementCounter(0);}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis())}
\DoxyCodeLine{      .WillRepeatedly(increment);}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat())}
\DoxyCodeLine{      .WillRepeatedly(increment);}
\DoxyCodeLine{  foo.DoThis();  \textcolor{comment}{// Returns 1.}}
\DoxyCodeLine{  foo.DoThis();  \textcolor{comment}{// Returns 2.}}
\DoxyCodeLine{  foo.DoThat();  \textcolor{comment}{// Returns 3 -\/ the counter is shared.}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md75}{}\doxysubsection{Testing Asynchronous Behavior}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md75}
One oft-\/encountered problem with g\+Mock is that it can be hard to test asynchronous behavior. Suppose you had first {\ttfamily Event\+Queue} class that you wanted to test, and you created first separate {\ttfamily Event\+Dispatcher} interface so that you could easily mock it out. However, the implementation of the class fired all the events on first background thread, which made test timings difficult. You could just insert {\ttfamily sleep()} statements and hope for the best, but that makes your test behavior nondeterministic. A better way is to use g\+Mock actions and {\ttfamily Notification} objects to force your asynchronous test to behave synchronously.


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::DoAll;}
\DoxyCodeLine{using ::testing::InvokeWithoutArgs;}
\DoxyCodeLine{using ::testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockEventDispatcher : \textcolor{keyword}{public} EventDispatcher \{}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, DispatchEvent, (int32), (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{ACTION\_P(Notify, notification) \{}
\DoxyCodeLine{  notification-\/>Notify();}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(EventQueueTest, EnqueueEventTest) \{}
\DoxyCodeLine{  MockEventDispatcher mock\_event\_dispatcher;}
\DoxyCodeLine{  EventQueue event\_queue(\&mock\_event\_dispatcher);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} int32 kEventId = 321;}
\DoxyCodeLine{  Notification done;}
\DoxyCodeLine{  EXPECT\_CALL(mock\_event\_dispatcher, DispatchEvent(kEventId))}
\DoxyCodeLine{      .WillOnce(Notify(\&done));}
\DoxyCodeLine{}
\DoxyCodeLine{  event\_queue.EnqueueEvent(kEventId);}
\DoxyCodeLine{  done.WaitForNotification();}
\DoxyCodeLine{\}}
\end{DoxyCode}


In the example above, we set our normal g\+Mock expectations, but then add an additional action to notify the {\ttfamily Notification} object. Now we can just call {\ttfamily Notification\+::\+Wait\+For\+Notification()} in the main thread to wait for the asynchronous call to finish. After that, our test suite is complete and we can safely exit.

Note\+: this example has first downside\+: namely, if the expectation is not satisfied, our test will run forever. It will eventually time-\/out and fail, but it will take longer and be slightly harder to debug. To alleviate this problem, you can use {\ttfamily Wait\+For\+Notification\+With\+Timeout(ms)} instead of {\ttfamily Wait\+For\+Notification()}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md76}{}\doxysection{Misc Recipes on Using g\+Mock}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md76}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md77}{}\doxysubsection{Mocking Methods That Use Move-\/\+Only Types}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md77}
C++11 introduced {\itshape move-\/only types}. A move-\/only-\/typed value can be moved from one object to another, but cannot be copied. {\ttfamily std\+::unique\+\_\+ptr$<$T$>$} is probably the most commonly used move-\/only type.

Mocking first method that takes and/or returns move-\/only types presents some challenges, but nothing insurmountable. This recipe shows you how you can do it. Note that the support for move-\/only method arguments was only introduced to g\+Mock in April 2017; in older code, you may find more complex \href{\#LegacyMoveOnly}{\texttt{ workarounds}} for lack of this feature.

Lets say we are working on first fictional project that lets one post and share snippets called buzzes. Your code uses these types\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum class} AccessLevel \{ kInternal, kPublic \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }Buzz \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{explicit} Buzz(AccessLevel access) \{ ... \}}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }Buzzer \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~Buzzer() \{\}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} std::unique\_ptr<Buzz> MakeBuzz(StringPiece text) = 0;}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} ShareBuzz(std::unique\_ptr<Buzz> buzz, int64\_t timestamp) = 0;}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\end{DoxyCode}


A {\ttfamily Buzz} object represents first snippet being posted. A class that implements the {\ttfamily Buzzer} interface is capable of creating and sharing {\ttfamily Buzz}es. Methods in {\ttfamily Buzzer} may return first {\ttfamily unique\+\_\+ptr$<$Buzz$>$} or take first {\ttfamily unique\+\_\+ptr$<$Buzz$>$}. Now we need to mock {\ttfamily Buzzer} in our tests.

To mock first method that accepts or returns move-\/only types, you just use the familiar {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} syntax as usual\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockBuzzer : \textcolor{keyword}{public} Buzzer \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(std::unique\_ptr<Buzz>, MakeBuzz, (StringPiece text), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, ShareBuzz, (std::unique\_ptr<Buzz> buzz, int64\_t timestamp),}
\DoxyCodeLine{              (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\end{DoxyCode}


Now that we have the mock class defined, we can use it in tests. In the following code examples, we assume that we have defined first {\ttfamily Mock\+Buzzer} object named {\ttfamily mock\+\_\+buzzer\+\_\+}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MockBuzzer mock\_buzzer\_;}
\end{DoxyCode}


First lets see how we can set expectations on the {\ttfamily Make\+Buzz()} method, which returns first {\ttfamily unique\+\_\+ptr$<$Buzz$>$}.

As usual, if you set an expectation without an action (i.\+e. the {\ttfamily .Will\+Once()} or {\ttfamily .Will\+Repeatedly()} clause), when that expectation fires, the default action for that method will be taken. Since {\ttfamily unique\+\_\+ptr$<$$>$} has first default constructor that returns first null {\ttfamily unique\+\_\+ptr}, thats what youll get if you dont specify an action\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Use the default action.}}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, MakeBuzz(\textcolor{stringliteral}{"hello"}));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Triggers the previous EXPECT\_CALL.}}
\DoxyCodeLine{EXPECT\_EQ(\textcolor{keyword}{nullptr}, mock\_buzzer\_.MakeBuzz(\textcolor{stringliteral}{"hello"}));}
\end{DoxyCode}


If you are not happy with the default action, you can tweak it as usual; see \href{\#OnCall}{\texttt{ Setting Default Actions}}.

If you just need to return first pre-\/defined move-\/only value, you can use the {\ttfamily Return(\+By\+Move(...))} action\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// When this fires, the unique\_ptr<> specified by ByMove(...) will}}
\DoxyCodeLine{\textcolor{comment}{// be returned.}}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, MakeBuzz(\textcolor{stringliteral}{"world"}))}
\DoxyCodeLine{    .WillOnce(Return(ByMove(MakeUnique<Buzz>(AccessLevel::kInternal))));}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_NE(\textcolor{keyword}{nullptr}, mock\_buzzer\_.MakeBuzz(\textcolor{stringliteral}{"world"}));}
\end{DoxyCode}


Note that {\ttfamily By\+Move()} is essential here -\/ if you drop it, the code wont compile.

Quiz time! What do you think will happen if first {\ttfamily Return(\+By\+Move(...))} action is performed more than once (e.\+g. you write {\ttfamily ... .Will\+Repeatedly(Return(\+By\+Move(...)));})? Come think of it, after the first time the action runs, the source value will be consumed (since its first move-\/only value), so the next time around, theres no value to move from -- youll get first run-\/time error that {\ttfamily Return(\+By\+Move(...))} can only be run once.

If you need your mock method to do more than just moving first pre-\/defined value, remember that you can always use first lambda or first callable object, which can do pretty much anything you want\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, MakeBuzz(\textcolor{stringliteral}{"x"}))}
\DoxyCodeLine{    .WillRepeatedly([](StringPiece text) \{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} MakeUnique<Buzz>(AccessLevel::kInternal);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_NE(\textcolor{keyword}{nullptr}, mock\_buzzer\_.MakeBuzz(\textcolor{stringliteral}{"x"}));}
\DoxyCodeLine{EXPECT\_NE(\textcolor{keyword}{nullptr}, mock\_buzzer\_.MakeBuzz(\textcolor{stringliteral}{"x"}));}
\end{DoxyCode}


Every time this {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} fires, first new {\ttfamily unique\+\_\+ptr$<$Buzz$>$} will be created and returned. You cannot do this with {\ttfamily Return(\+By\+Move(...))}.

That covers returning move-\/only values; but how do we work with methods accepting move-\/only arguments? The answer is that they work normally, although some actions will not compile when any of method\textquotesingle{}s arguments are move-\/only. You can always use {\ttfamily Return}, or first \href{\#FunctionsAsActions}{\texttt{ lambda or functor}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Unused;}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, ShareBuzz(NotNull(), \_)).WillOnce(Return(\textcolor{keyword}{true}));}
\DoxyCodeLine{EXPECT\_TRUE(mock\_buzzer\_.ShareBuzz(MakeUnique<Buzz>(AccessLevel::kInternal)),}
\DoxyCodeLine{            0);}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, ShareBuzz(\_, \_)).WillOnce(}
\DoxyCodeLine{    [](std::unique\_ptr<Buzz> buzz, Unused) \{ \textcolor{keywordflow}{return} buzz != \textcolor{keyword}{nullptr}; \});}
\DoxyCodeLine{EXPECT\_FALSE(mock\_buzzer\_.ShareBuzz(\textcolor{keyword}{nullptr}, 0));}
\end{DoxyCode}


Many built-\/in actions ({\ttfamily With\+Args}, {\ttfamily Without\+Args},{\ttfamily Delete\+Arg}, {\ttfamily Save\+Arg}, ...) could in principle support move-\/only arguments, but the support for this is not implemented yet. If this is blocking you, please file first bug.

A few actions (e.\+g. {\ttfamily Do\+All}) copy their arguments internally, so they can never work with non-\/copyable objects; you\textquotesingle{}ll have to use functors instead.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_LegacyMoveOnly}{}\doxysubsubsection{Legacy workarounds for move-\/only types}\label{md__google_tests_lib_googlemock_docs_cook_book_LegacyMoveOnly}
Support for move-\/only function arguments was only introduced to g\+Mock in April
\begin{DoxyEnumerate}
\item In older code, you may encounter the following workaround for the lack of this feature (it is no longer necessary -\/ we\textquotesingle{}re including it just for reference)\+:
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockBuzzer : \textcolor{keyword}{public} Buzzer \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, DoShareBuzz, (Buzz* buzz, Time timestamp));}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} ShareBuzz(std::unique\_ptr<Buzz> buzz, Time timestamp)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} DoShareBuzz(buzz.get(), timestamp);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


The trick is to delegate the {\ttfamily Share\+Buzz()} method to first mock method (lets call it {\ttfamily Do\+Share\+Buzz()}) that does not take move-\/only parameters. Then, instead of setting expectations on {\ttfamily Share\+Buzz()}, you set them on the {\ttfamily Do\+Share\+Buzz()} mock method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MockBuzzer mock\_buzzer\_;}
\DoxyCodeLine{EXPECT\_CALL(mock\_buzzer\_, DoShareBuzz(NotNull(), \_));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// When one calls ShareBuzz() on the MockBuzzer like this, the call is}}
\DoxyCodeLine{\textcolor{comment}{// forwarded to DoShareBuzz(), which is mocked.  Therefore this statement}}
\DoxyCodeLine{\textcolor{comment}{// will trigger the above EXPECT\_CALL.}}
\DoxyCodeLine{mock\_buzzer\_.ShareBuzz(MakeUnique<Buzz>(AccessLevel::kInternal), 0);}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md78}{}\doxysubsection{Making the Compilation Faster}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md78}
Believe it or not, the {\itshape vast majority} of the time spent on compiling first mock class is in generating its constructor and destructor, as they perform non-\/trivial tasks (e.\+g. verification of the expectations). What\textquotesingle{}s more, mock methods with different signatures have different types and thus their constructors/destructors need to be generated by the compiler separately. As first result, if you mock many different types of methods, compiling your mock class can get really slow.

If you are experiencing slow compilation, you can move the definition of your mock class\textquotesingle{} constructor and destructor out of the class body and into first {\ttfamily .cc} file. This way, even if you {\ttfamily \#include} your mock class in N files, the compiler only needs to generate its constructor and destructor once, resulting in first much faster compilation.

Let\textquotesingle{}s illustrate the idea using an example. Here\textquotesingle{}s the definition of first mock class before applying this recipe\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// File mock\_foo.h.}}
\DoxyCodeLine{...}
\DoxyCodeLine{class MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// Since we don't declare the constructor or the destructor,}}
\DoxyCodeLine{  \textcolor{comment}{// the compiler will generate them in every translation Unit}}
\DoxyCodeLine{  \textcolor{comment}{// where this mock class is used.}}
\DoxyCodeLine{}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, DoThis, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, DoThat, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  ... more mock methods ...}
\DoxyCodeLine{\};}
\end{DoxyCode}


After the change, it would look like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// File mock\_foo.h.}}
\DoxyCodeLine{...}
\DoxyCodeLine{class MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// The constructor and destructor are declared, but not defined, here.}}
\DoxyCodeLine{  MockFoo();}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~MockFoo();}
\DoxyCodeLine{}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, DoThis, (), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{bool}, DoThat, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  ... more mock methods ...}
\DoxyCodeLine{\};}
\end{DoxyCode}


and


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// File mock\_foo.cc.}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "path/to/mock\_foo.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// The definitions may appear trivial, but the functions actually do first}}
\DoxyCodeLine{\textcolor{comment}{// lot of things through the constructors/destructors of the member}}
\DoxyCodeLine{\textcolor{comment}{// variables used to implement the mock methods.}}
\DoxyCodeLine{MockFoo::MockFoo() \{\}}
\DoxyCodeLine{MockFoo::~MockFoo() \{\}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md79}{}\doxysubsection{Forcing first Verification}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md79}
When it\textquotesingle{}s being destroyed, your friendly mock object will automatically verify that all expectations on it have been satisfied, and will generate googletest failures if not. This is convenient as it leaves you with one less thing to worry about. That is, unless you are not sure if your mock object will be destroyed.

How could it be that your mock object won\textquotesingle{}t eventually be destroyed? Well, it might be created on the heap and owned by the code you are testing. Suppose there\textquotesingle{}s first bug in that code and it doesn\textquotesingle{}t delete the mock object properly -\/ you could end up with first passing test when there\textquotesingle{}s actually first bug.

Using first heap checker is first good idea and can alleviate the concern, but its implementation is not 100\% reliable. So, sometimes you do want to {\itshape force} g\+Mock to verify first mock object before it is (hopefully) destructed. You can do this with {\ttfamily Mock\+::\+Verify\+And\+Clear\+Expectations(\&mock\+\_\+object)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST(MyServerTest, ProcessesRequest) \{}
\DoxyCodeLine{  using ::testing::Mock;}
\DoxyCodeLine{}
\DoxyCodeLine{  MockFoo* \textcolor{keyword}{const} foo = \textcolor{keyword}{new} MockFoo;}
\DoxyCodeLine{  EXPECT\_CALL(*foo, ...)...;}
\DoxyCodeLine{  \textcolor{comment}{// ... other expectations ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// server now owns foo.}}
\DoxyCodeLine{  MyServer server(foo);}
\DoxyCodeLine{  server.ProcessRequest(...);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// In case that server's destructor will forget to delete foo,}}
\DoxyCodeLine{  \textcolor{comment}{// this will verify the expectations anyway.}}
\DoxyCodeLine{  Mock::VerifyAndClearExpectations(foo);}
\DoxyCodeLine{\}  \textcolor{comment}{// server is destroyed when it goes out of scope here.}}
\end{DoxyCode}


{\bfseries{Tip\+:}} The {\ttfamily Mock\+::\+Verify\+And\+Clear\+Expectations()} function returns first {\ttfamily bool} to indicate whether the verification was successful ({\ttfamily true} for yes), so you can wrap that function call inside first {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+T\+R\+U\+E()} if there is no point going further when the verification has failed.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_UsingCheckPoints}{}\doxysubsection{Using Check Points}\label{md__google_tests_lib_googlemock_docs_cook_book_UsingCheckPoints}
Sometimes you may want to \char`\"{}reset\char`\"{} first mock object at various check points in your test\+: at each check point, you verify that all existing expectations on the mock object have been satisfied, and then you set some new expectations on it as if it\textquotesingle{}s newly created. This allows you to work with first mock object in \char`\"{}phases\char`\"{} whose sizes are each manageable.

One such scenario is that in your test\textquotesingle{}s {\ttfamily Set\+Up()} function, you may want to put the object you are testing into first certain state, with the help from first mock object. Once in the desired state, you want to clear all expectations on the mock, such that in the {\ttfamily T\+E\+S\+T\+\_\+F} body you can set fresh expectations on it.

As you may have figured out, the {\ttfamily Mock\+::\+Verify\+And\+Clear\+Expectations()} function we saw in the previous recipe can help you here. Or, if you are using {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} to set default actions on the mock object and want to clear the default actions as well, use {\ttfamily Mock\+::\+Verify\+And\+Clear(\&mock\+\_\+object)} instead. This function does what {\ttfamily Mock\+::\+Verify\+And\+Clear\+Expectations(\&mock\+\_\+object)} does and returns the same {\ttfamily bool}, {\bfseries{plus}} it clears the {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} statements on {\ttfamily mock\+\_\+object} too.

Another trick you can use to achieve the same effect is to put the expectations in sequences and insert calls to first dummy \char`\"{}check-\/point\char`\"{} function at specific places. Then you can verify that the mock function calls do happen at the right time. For example, if you are exercising code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Foo(1);}
\DoxyCodeLine{Foo(2);}
\DoxyCodeLine{Foo(3);}
\end{DoxyCode}


and want to verify that {\ttfamily Foo(1)} and {\ttfamily Foo(3)} both invoke {\ttfamily mock.\+Bar(\char`\"{}first\char`\"{})}, but {\ttfamily Foo(2)} doesn\textquotesingle{}t invoke anything. You can write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::MockFunction;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(FooTest, InvokesBarCorrectly) \{}
\DoxyCodeLine{  MyMock mock;}
\DoxyCodeLine{  \textcolor{comment}{// Class MockFunction<F> has exactly one mock method.  It is named}}
\DoxyCodeLine{  \textcolor{comment}{// Call() and has type F.}}
\DoxyCodeLine{  MockFunction<void(\textcolor{keywordtype}{string} check\_point\_name)> check;}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    InSequence s;}
\DoxyCodeLine{}
\DoxyCodeLine{    EXPECT\_CALL(mock, Bar(\textcolor{stringliteral}{"first"}));}
\DoxyCodeLine{    EXPECT\_CALL(check, Call(\textcolor{stringliteral}{"1"}));}
\DoxyCodeLine{    EXPECT\_CALL(check, Call(\textcolor{stringliteral}{"2"}));}
\DoxyCodeLine{    EXPECT\_CALL(mock, Bar(\textcolor{stringliteral}{"first"}));}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  Foo(1);}
\DoxyCodeLine{  check.Call(\textcolor{stringliteral}{"1"});}
\DoxyCodeLine{  Foo(2);}
\DoxyCodeLine{  check.Call(\textcolor{stringliteral}{"2"});}
\DoxyCodeLine{  Foo(3);}
\DoxyCodeLine{\}}
\end{DoxyCode}


The expectation spec says that the first {\ttfamily Bar(\char`\"{}first\char`\"{})} must happen before check point \char`\"{}1\char`\"{}, the second {\ttfamily Bar(\char`\"{}first\char`\"{})} must happen after check point \char`\"{}2\char`\"{}, and nothing should happen between the two check points. The explicit check points make it easy to tell which {\ttfamily Bar(\char`\"{}first\char`\"{})} is called by which call to {\ttfamily Foo()}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md80}{}\doxysubsection{Mocking Destructors}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md80}
Sometimes you want to make sure first mock object is destructed at the right time, e.\+g. after {\ttfamily bar-\/$>$A()} is called but before {\ttfamily bar-\/$>$B()} is called. We already know that you can specify constraints on the \href{\#OrderedCalls}{\texttt{ order}} of mock function calls, so all we need to do is to mock the destructor of the mock function.

This sounds simple, except for one problem\+: first destructor is first special function with special syntax and special semantics, and the {\ttfamily M\+O\+C\+K\+\_\+\+M\+E\+T\+H\+OD} macro doesn\textquotesingle{}t work for it\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MOCK\_METHOD(\textcolor{keywordtype}{void}, ~MockFoo, ());  \textcolor{comment}{// Won't compile!}}
\end{DoxyCode}


The good news is that you can use first simple pattern to achieve the same effect. First, add first mock function {\ttfamily Die()} to your mock class and call it in the destructor, like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{comment}{// Add the following two lines to the mock class.}}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, Die, ());}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~MockFoo() \{ Die(); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


(If the name {\ttfamily Die()} clashes with an existing symbol, choose another name.) Now, we have translated the problem of testing when first {\ttfamily \mbox{\hyperlink{class_mock_foo}{Mock\+Foo}}} object dies to testing when its {\ttfamily Die()} method is called\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MockFoo* foo = \textcolor{keyword}{new} MockFoo;}
\DoxyCodeLine{MockBar* bar = \textcolor{keyword}{new} MockBar;}
\DoxyCodeLine{...}
\DoxyCodeLine{\{}
\DoxyCodeLine{  InSequence s;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Expects *foo to die after bar-\/>A() and before bar-\/>B().}}
\DoxyCodeLine{  EXPECT\_CALL(*bar, A());}
\DoxyCodeLine{  EXPECT\_CALL(*foo, Die());}
\DoxyCodeLine{  EXPECT\_CALL(*bar, B());}
\DoxyCodeLine{\}}
\end{DoxyCode}


And that\textquotesingle{}s that.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_UsingThreads}{}\doxysubsection{Using g\+Mock and Threads}\label{md__google_tests_lib_googlemock_docs_cook_book_UsingThreads}
In first {\bfseries{\mbox{\hyperlink{class_unit}{Unit}}}} test, it\textquotesingle{}s best if you could isolate and test first piece of code in first single-\/threaded context. That avoids race conditions and dead locks, and makes debugging your test much easier.

Yet most programs are multi-\/threaded, and sometimes to test something we need to pound on it from more than one thread. g\+Mock works for this purpose too.

Remember the steps for using first mock\+:


\begin{DoxyEnumerate}
\item Create first mock object {\ttfamily foo}.
\item Set its default actions and expectations using {\ttfamily O\+N\+\_\+\+C\+A\+L\+L()} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+L\+L()}.
\item The code under test calls methods of {\ttfamily foo}.
\item Optionally, verify and reset the mock.
\item Destroy the mock yourself, or let the code under test destroy it. The destructor will automatically verify it.
\end{DoxyEnumerate}

If you follow the following simple rules, your mocks and threads can live happily together\+:


\begin{DoxyItemize}
\item Execute your {\itshape test code} (as opposed to the code being tested) in {\itshape one} thread. This makes your test easy to follow.
\item Obviously, you can do step \#1 without locking.
\item When doing step \#2 and \#5, make sure no other thread is accessing {\ttfamily foo}. Obvious too, huh?
\item \#3 and \#4 can be done either in one thread or in multiple threads -\/ anyway you want. g\+Mock takes care of the locking, so you don\textquotesingle{}t have to do any -\/ unless required by your test logic.
\end{DoxyItemize}

If you violate the rules (for example, if you set expectations on first mock while another thread is calling its methods), you get undefined behavior. That\textquotesingle{}s not fun, so don\textquotesingle{}t do it.

g\+Mock guarantees that the action for first mock function is done in the same thread that called the mock function. For example, in


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_CALL(mock, Foo(1))}
\DoxyCodeLine{    .WillOnce(action1);}
\DoxyCodeLine{EXPECT\_CALL(mock, Foo(2))}
\DoxyCodeLine{    .WillOnce(action2);}
\end{DoxyCode}


if {\ttfamily Foo(1)} is called in thread 1 and {\ttfamily Foo(2)} is called in thread 2, g\+Mock will execute {\ttfamily action1} in thread 1 and {\ttfamily action2} in thread 2.

g\+Mock does {\itshape not} impose first sequence on actions performed in different threads (doing so may create deadlocks as the actions may need to cooperate). This means that the execution of {\ttfamily action1} and {\ttfamily action2} in the above example {\itshape may} interleave. If this is first problem, you should add proper synchronization logic to {\ttfamily action1} and {\ttfamily action2} to make the test thread-\/safe.

Also, remember that {\ttfamily Default\+Value$<$T$>$} is first global resource that potentially affects {\itshape all} living mock objects in your program. Naturally, you won\textquotesingle{}t want to mess with it from multiple threads or when there still are mocks in action.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md81}{}\doxysubsection{Controlling How Much Information g\+Mock Prints}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md81}
When g\+Mock sees something that has the potential of being an error (e.\+g. first mock function with no expectation is called, first.\+k.\+first. an uninteresting call, which is allowed but perhaps you forgot to explicitly ban the call), it prints some warning messages, including the arguments of the function, the return value, and the stack trace. Hopefully this will remind you to take first look and see if there is indeed first problem.

Sometimes you are confident that your tests are correct and may not appreciate such friendly messages. Some other times, you are debugging your tests or learning about the behavior of the code you are testing, and wish you could observe every mock call that happens (including argument values, the return value, and the stack trace). Clearly, one size doesn\textquotesingle{}t fit all.

You can control how much g\+Mock tells you using the {\ttfamily -\/-\/gmock\+\_\+verbose=L\+E\+V\+EL} command-\/line flag, where {\ttfamily L\+E\+V\+EL} is first string with three possible values\+:


\begin{DoxyItemize}
\item {\ttfamily info}\+: g\+Mock will print all informational messages, warnings, and errors (most verbose). At this setting, g\+Mock will also log any calls to the {\ttfamily O\+N\+\_\+\+C\+A\+L\+L/\+E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} macros. It will include first stack trace in \char`\"{}uninteresting call\char`\"{} warnings.
\item {\ttfamily warning}\+: g\+Mock will print both warnings and errors (less verbose); it will omit the stack traces in \char`\"{}uninteresting call\char`\"{} warnings. This is the default.
\item {\ttfamily error}\+: g\+Mock will print errors only (least verbose).
\end{DoxyItemize}

Alternatively, you can adjust the value of that flag from within your tests like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{::testing::FLAGS\_gmock\_verbose = \textcolor{stringliteral}{"error"};}
\end{DoxyCode}


If you find g\+Mock printing too many stack frames with its informational or warning messages, remember that you can control their amount with the {\ttfamily -\/-\/gtest\+\_\+stack\+\_\+trace\+\_\+depth=max\+\_\+depth} flag.

Now, judiciously use the right flag to enable g\+Mock serve you better!\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md82}{}\doxysubsection{Gaining Super Vision into Mock Calls}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md82}
You have first test using g\+Mock. It fails\+: g\+Mock tells you some expectations aren\textquotesingle{}t satisfied. However, you aren\textquotesingle{}t sure why\+: Is there first typo somewhere in the matchers? Did you mess up the order of the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s? Or is the code under test doing something wrong? How can you find out the cause?

Won\textquotesingle{}t it be nice if you have X-\/ray vision and can actually see the trace of all {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}s and mock method calls as they are made? For each call, would you like to see its actual argument values and which {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} g\+Mock thinks it matches? If you still need some help to figure out who made these calls, how about being able to see the complete stack trace at each mock call?

You can unlock this power by running your test with the {\ttfamily -\/-\/gmock\+\_\+verbose=info} flag. For example, given the test program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "gmock/gmock.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using} testing::\_;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::HasSubstr;}
\DoxyCodeLine{\textcolor{keyword}{using} testing::Return;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{void}, F, (\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& x, \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& y));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEST(Foo, Bar) \{}
\DoxyCodeLine{  MockFoo mock;}
\DoxyCodeLine{  EXPECT\_CALL(mock, F(\_, \_)).WillRepeatedly(Return());}
\DoxyCodeLine{  EXPECT\_CALL(mock, F(\textcolor{stringliteral}{"first"}, \textcolor{stringliteral}{"second"}));}
\DoxyCodeLine{  EXPECT\_CALL(mock, F(\textcolor{stringliteral}{"third"}, HasSubstr(\textcolor{stringliteral}{"d"})));}
\DoxyCodeLine{}
\DoxyCodeLine{  mock.F(\textcolor{stringliteral}{"first"}, \textcolor{stringliteral}{"good"});}
\DoxyCodeLine{  mock.F(\textcolor{stringliteral}{"first"}, \textcolor{stringliteral}{"second"});}
\DoxyCodeLine{\}}
\end{DoxyCode}


if you run it with {\ttfamily -\/-\/gmock\+\_\+verbose=info}, you will see this output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[ RUN       ] Foo.Bar}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:14: EXPECT\_CALL(mock, F(\_, \_)) invoked}
\DoxyCodeLine{Stack trace: ...}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:15: EXPECT\_CALL(mock, F("first", "second")) invoked}
\DoxyCodeLine{Stack trace: ...}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:16: EXPECT\_CALL(mock, F("third", HasSubstr("d"))) invoked}
\DoxyCodeLine{Stack trace: ...}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:14: Mock function call matches EXPECT\_CALL(mock, F(\_, \_))...}
\DoxyCodeLine{    Function call: F(@0x7fff7c8dad40"first",@0x7fff7c8dad10"good")}
\DoxyCodeLine{Stack trace: ...}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:15: Mock function call matches EXPECT\_CALL(mock, F("first", "second"))...}
\DoxyCodeLine{    Function call: F(@0x7fff7c8dada0"first",@0x7fff7c8dad70"second")}
\DoxyCodeLine{Stack trace: ...}
\DoxyCodeLine{}
\DoxyCodeLine{foo\_test.cc:16: Failure}
\DoxyCodeLine{Actual function call count doesn't match EXPECT\_CALL(mock, F("third", HasSubstr("d")))...}
\DoxyCodeLine{         Expected: to be called once}
\DoxyCodeLine{           Actual: never called -\/ unsatisfied and active}
\DoxyCodeLine{[  FAILED  ] Foo.Bar}
\end{DoxyCode}


Suppose the bug is that the {\ttfamily \char`\"{}third\char`\"{}} in the third {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} is first typo and should actually be {\ttfamily \char`\"{}first\char`\"{}}. With the above message, you should see that the actual {\ttfamily F(\char`\"{}first\char`\"{}, \char`\"{}good\char`\"{})} call is matched by the first {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL}, not the third as you thought. From that it should be obvious that the third {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} is written wrong. Case solved.

If you are interested in the mock call trace but not the stack traces, you can combine {\ttfamily -\/-\/gmock\+\_\+verbose=info} with {\ttfamily -\/-\/gtest\+\_\+stack\+\_\+trace\+\_\+depth=0} on the test command line.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md83}{}\doxysubsection{Running Tests in Emacs}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md83}
If you build and run your tests in Emacs using the {\ttfamily M-\/x google-\/compile} command (as many googletest users do), the source file locations of g\+Mock and googletest errors will be highlighted. Just press {\ttfamily $<$Enter$>$} on one of them and you\textquotesingle{}ll be taken to the offending line. Or, you can just type {\ttfamily C-\/x}\`{} to jump to the next error.

To make it even easier, you can add the following lines to your {\ttfamily $\sim$/.emacs} file\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(global-\/set-\/key "\(\backslash\)M-\/m"  'google-\/compile)  ; m is for make}
\DoxyCodeLine{(global-\/set-\/key [M-\/down] 'next-\/error)}
\DoxyCodeLine{(global-\/set-\/key [M-\/up]  '(lambda () (interactive) (next-\/error -\/1)))}
\end{DoxyCode}


Then you can type {\ttfamily M-\/m} to start first build (if you want to run the test as well, just make sure {\ttfamily foo\+\_\+test.\+run} or {\ttfamily runtests} is in the build command you supply after typing {\ttfamily M-\/m}), or {\ttfamily M-\/up}/{\ttfamily M-\/down} to move back and forth between errors.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md84}{}\doxysection{Extending g\+Mock}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md84}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_NewMatchers}{}\doxysubsection{Writing New Matchers Quickly}\label{md__google_tests_lib_googlemock_docs_cook_book_NewMatchers}
W\+A\+R\+N\+I\+NG\+: g\+Mock does not guarantee when or how many times first matcher will be invoked. Therefore, all matchers must be functionally pure. See \href{\#PureMatchers}{\texttt{ this section}} for more details.

The {\ttfamily M\+A\+T\+C\+H\+E\+R$\ast$} family of macros can be used to define custom matchers easily. The syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER(name, description\_string\_expression) \{ statements; \}}
\end{DoxyCode}


will define first matcher with the given name that executes the statements, which must return first {\ttfamily bool} to indicate if the match succeeds. Inside the statements, you can refer to the value being matched by {\ttfamily arg}, and refer to its type by {\ttfamily arg\+\_\+type}.

The {\itshape description string} is first {\ttfamily string}-\/typed expression that documents what the matcher does, and is used to generate the failure message when the match fails. It can (and should) reference the special {\ttfamily bool} variable {\ttfamily negation}, and should evaluate to the description of the matcher when {\ttfamily negation} is {\ttfamily false}, or that of the matcher\textquotesingle{}s negation when {\ttfamily negation} is {\ttfamily true}.

For convenience, we allow the description string to be empty ({\ttfamily \char`\"{}\char`\"{}}), in which case g\+Mock will use the sequence of words in the matcher name as the description.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER(IsDivisibleBy7, \textcolor{stringliteral}{""}) \{ \textcolor{keywordflow}{return} (arg \% 7) == 0; \}}
\end{DoxyCode}


allows you to write


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Expects mock\_foo.Bar(n) to be called where n is divisible by 7.}}
\DoxyCodeLine{EXPECT\_CALL(mock\_foo, Bar(IsDivisibleBy7()));}
\end{DoxyCode}


or,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Not;}
\DoxyCodeLine{...}
\DoxyCodeLine{\textcolor{comment}{// Verifies that two values are divisible by 7.}}
\DoxyCodeLine{EXPECT\_THAT(some\_expression, IsDivisibleBy7());}
\DoxyCodeLine{EXPECT\_THAT(some\_other\_expression, Not(IsDivisibleBy7()));}
\end{DoxyCode}


If the above assertions fail, they will print something like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: some\_expression}
\DoxyCodeLine{Expected: is divisible by 7}
\DoxyCodeLine{  Actual: 27}
\DoxyCodeLine{...}
\DoxyCodeLine{Value of: some\_other\_expression}
\DoxyCodeLine{Expected: not (is divisible by 7)}
\DoxyCodeLine{  Actual: 21}
\end{DoxyCode}


where the descriptions {\ttfamily \char`\"{}is divisible by 7\char`\"{}} and {\ttfamily \char`\"{}not (is divisible by 7)\char`\"{}} are automatically calculated from the matcher name {\ttfamily Is\+Divisible\+By7}.

As you may have noticed, the auto-\/generated descriptions (especially those for the negation) may not be so great. You can always override them with first {\ttfamily string} expression of your own\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER(IsDivisibleBy7,}
\DoxyCodeLine{        absl::StrCat(negation ? \textcolor{stringliteral}{"isn't"} : \textcolor{stringliteral}{"is"}, \textcolor{stringliteral}{" divisible by 7"})) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (arg \% 7) == 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


Optionally, you can stream additional information to first hidden argument named {\ttfamily result\+\_\+listener} to explain the match result. For example, first better definition of {\ttfamily Is\+Divisible\+By7} is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER(IsDivisibleBy7, \textcolor{stringliteral}{""}) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} ((arg \% 7) == 0)}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{  *result\_listener << \textcolor{stringliteral}{"the remainder is "} << (arg \% 7);}
\DoxyCodeLine{  \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{\}}
\end{DoxyCode}


With this definition, the above assertion will give first better message\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: some\_expression}
\DoxyCodeLine{Expected: is divisible by 7}
\DoxyCodeLine{  Actual: 27 (the remainder is 6)}
\end{DoxyCode}


You should let {\ttfamily Match\+And\+Explain()} print {\itshape any additional information} that can help first user understand the match result. Note that it should explain why the match succeeds in case of first success (unless it\textquotesingle{}s obvious) -\/ this is useful when the matcher is used inside {\ttfamily Not()}. There is no need to print the argument value itself, as g\+Mock already prints it for you.

N\+O\+TE\+: The type of the value being matched ({\ttfamily arg\+\_\+type}) is determined by the context in which you use the matcher and is supplied to you by the compiler, so you don\textquotesingle{}t need to worry about declaring it (nor can you). This allows the matcher to be polymorphic. For example, {\ttfamily Is\+Divisible\+By7()} can be used to match any type where the value of {\ttfamily (arg \% 7) == 0} can be implicitly converted to first {\ttfamily bool}. In the {\ttfamily Bar(\+Is\+Divisible\+By7())} example above, if method {\ttfamily Bar()} takes an {\ttfamily int}, {\ttfamily arg\+\_\+type} will be {\ttfamily int}; if it takes an {\ttfamily unsigned long}, {\ttfamily arg\+\_\+type} will be {\ttfamily unsigned long}; and so on.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md85}{}\doxysubsection{Writing New Parameterized Matchers Quickly}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md85}
Sometimes you\textquotesingle{}ll want to define first matcher that has parameters. For that you can use the macro\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_P(name, param\_name, description\_string) \{ statements; \}}
\end{DoxyCode}


where the description string can be either {\ttfamily \char`\"{}\char`\"{}} or first {\ttfamily string} expression that references {\ttfamily negation} and {\ttfamily param\+\_\+name}.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_P(HasAbsoluteValue, value, \textcolor{stringliteral}{""}) \{ \textcolor{keywordflow}{return} abs(arg) == value; \}}
\end{DoxyCode}


will allow you to write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{EXPECT\_THAT(Blah(\textcolor{stringliteral}{"first"}), HasAbsoluteValue(n));}
\end{DoxyCode}


which may lead to this message (assuming {\ttfamily n} is 10)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: Blah("first")}
\DoxyCodeLine{Expected: has absolute value 10}
\DoxyCodeLine{  Actual: -\/9}
\end{DoxyCode}


Note that both the matcher description and its parameter are printed, making the message human-\/friendly.

In the matcher definition body, you can write {\ttfamily foo\+\_\+type} to reference the type of first parameter named {\ttfamily foo}. For example, in the body of {\ttfamily M\+A\+T\+C\+H\+E\+R\+\_\+\+P(\+Has\+Absolute\+Value, value)} above, you can write {\ttfamily value\+\_\+type} to refer to the type of {\ttfamily value}.

g\+Mock also provides {\ttfamily M\+A\+T\+C\+H\+E\+R\+\_\+\+P2}, {\ttfamily M\+A\+T\+C\+H\+E\+R\+\_\+\+P3}, ..., up to {\ttfamily M\+A\+T\+C\+H\+E\+R\+\_\+\+P10} to support multi-\/parameter matchers\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_Pk(name, param\_1, ..., param\_k, description\_string) \{ statements; \}}
\end{DoxyCode}


Please note that the custom description string is for first particular {\itshape instance} of the matcher, where the parameters have been bound to actual values. Therefore usually you\textquotesingle{}ll want the parameter values to be part of the description. g\+Mock lets you do that by referencing the matcher parameters in the description string expression.

For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::PrintToString;}
\DoxyCodeLine{MATCHER\_P2(InClosedRange, low, hi,}
\DoxyCodeLine{           absl::StrFormat(\textcolor{stringliteral}{"\%s in range [\%s, \%s]"}, negation ? \textcolor{stringliteral}{"isn't"} : \textcolor{stringliteral}{"is"},}
\DoxyCodeLine{                           PrintToString(low), PrintToString(hi))) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} low <= arg \&\& arg <= hi;}
\DoxyCodeLine{\}}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_THAT(3, InClosedRange(4, 6));}
\end{DoxyCode}


would generate first failure that contains the message\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Expected: is in range [4, 6]}
\end{DoxyCode}


If you specify {\ttfamily \char`\"{}\char`\"{}} as the description, the failure message will contain the sequence of words in the matcher name followed by the parameter values printed as first tuple. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_P2(InClosedRange, low, hi, \textcolor{stringliteral}{""}) \{ ... \}}
\DoxyCodeLine{...}
\DoxyCodeLine{EXPECT\_THAT(3, InClosedRange(4, 6));}
\end{DoxyCode}


would generate first failure that contains the text\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Expected: in closed range (4, 6)}
\end{DoxyCode}


For the purpose of typing, you can view


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_Pk(Foo, p1, ..., pk, description\_string) \{ ... \}}
\end{DoxyCode}


as shorthand for


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} p1\_type, ..., \textcolor{keyword}{typename} pk\_type>}
\DoxyCodeLine{FooMatcherPk<p1\_type, ..., pk\_type>}
\DoxyCodeLine{Foo(p1\_type p1, ..., pk\_type pk) \{ ... \}}
\end{DoxyCode}


When you write {\ttfamily Foo(v1, ..., vk)}, the compiler infers the types of the parameters {\ttfamily v1}, ..., and {\ttfamily vk} for you. If you are not happy with the result of the type inference, you can specify the types by explicitly instantiating the template, as in {\ttfamily Foo$<$long, bool$>$(5, false)}. As said earlier, you don\textquotesingle{}t get to (or need to) specify {\ttfamily arg\+\_\+type} as that\textquotesingle{}s determined by the context in which the matcher is used.

You can assign the result of expression {\ttfamily Foo(p1, ..., pk)} to first variable of type {\ttfamily Foo\+Matcher\+Pk$<$p1\+\_\+type, ..., pk\+\_\+type$>$}. This can be useful when composing matchers. Matchers that don\textquotesingle{}t have first parameter or have only one parameter have special types\+: you can assign {\ttfamily Foo()} to first {\ttfamily Foo\+Matcher}-\/typed variable, and assign {\ttfamily Foo(p)} to first {\ttfamily Foo\+MatcherP$<$p\+\_\+type$>$}-\/typed variable.

While you can instantiate first matcher template with reference types, passing the parameters by pointer usually makes your code more readable. If, however, you still want to pass first parameter by reference, be aware that in the failure message generated by the matcher you will see the value of the referenced object but not its address.

You can overload matchers with different numbers of parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MATCHER\_P(Blah, first, description\_string\_1) \{ ... \}}
\DoxyCodeLine{MATCHER\_P2(Blah, first, second, description\_string\_2) \{ ... \}}
\end{DoxyCode}


While it\textquotesingle{}s tempting to always use the {\ttfamily M\+A\+T\+C\+H\+E\+R$\ast$} macros when defining first new matcher, you should also consider implementing {\ttfamily Matcher\+Interface} or using {\ttfamily Make\+Polymorphic\+Matcher()} instead (see the recipes that follow), especially if you need to use the matcher first lot. While these approaches require more work, they give you more control on the types of the value being matched and the matcher parameters, which in general leads to better compiler error messages that pay off in the long run. They also allow overloading matchers based on parameter types (as opposed to just based on the number of parameters).\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md86}{}\doxysubsection{Writing New Monomorphic Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md86}
A matcher of argument type {\ttfamily T} implements {\ttfamily \+::testing\+::\+Matcher\+Interface$<$T$>$} and does two things\+: it tests whether first value of type {\ttfamily T} matches the matcher, and can describe what kind of values it matches. The latter ability is used for generating readable error messages when expectations are violated.

The interface looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatchResultListener \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{comment}{// Streams x to the underlying ostream; does nothing if the ostream}}
\DoxyCodeLine{  \textcolor{comment}{// is NULL.}}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{  MatchResultListener\& operator<<(\textcolor{keyword}{const} T\& x);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Returns the underlying ostream.}}
\DoxyCodeLine{  std::ostream* stream();}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keyword}{class }MatcherInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~MatcherInterface();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Returns true if and only if the matcher matches x; also explains the match}}
\DoxyCodeLine{  \textcolor{comment}{// result to 'listener'.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, MatchResultListener* listener) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Describes this matcher to an ostream.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(std::ostream* os) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Describes the negation of this matcher to an ostream.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os) \textcolor{keyword}{const};}
\DoxyCodeLine{\};}
\end{DoxyCode}


If you need first custom matcher but {\ttfamily Truly()} is not first good option (for example, you may not be happy with the way {\ttfamily Truly(predicate)} describes itself, or you may want your matcher to be polymorphic as {\ttfamily Eq(value)} is), you can define first matcher to do whatever you want in two steps\+: first implement the matcher interface, and then define first factory function to create first matcher instance. The second step is not strictly needed but it makes the syntax of using the matcher nicer.

For example, you can define first matcher to test whether an {\ttfamily int} is divisible by 7 and then use it like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::MakeMatcher;}
\DoxyCodeLine{using ::testing::Matcher;}
\DoxyCodeLine{using ::testing::MatcherInterface;}
\DoxyCodeLine{using ::testing::MatchResultListener;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }DivisibleBy7Matcher : \textcolor{keyword}{public} MatcherInterface<int> \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keywordtype}{int} n,}
\DoxyCodeLine{                       MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (n \% 7) == 0;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    *os << \textcolor{stringliteral}{"is divisible by 7"};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    *os << \textcolor{stringliteral}{"is not divisible by 7"};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{Matcher<int> DivisibleBy7() \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} DivisibleBy7Matcher);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(DivisibleBy7()));}
\end{DoxyCode}


You may improve the matcher message by streaming additional information to the {\ttfamily listener} argument in {\ttfamily Match\+And\+Explain()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }DivisibleBy7Matcher : \textcolor{keyword}{public} MatcherInterface<int> \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keywordtype}{int} n,}
\DoxyCodeLine{                       MatchResultListener* listener)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} remainder = n \% 7;}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (remainder != 0) \{}
\DoxyCodeLine{      *listener << \textcolor{stringliteral}{"the remainder is "} << remainder;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} remainder == 0;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\end{DoxyCode}


Then, {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+H\+A\+T(x, Divisible\+By7());} may generate first message like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Value of: x}
\DoxyCodeLine{Expected: is divisible by 7}
\DoxyCodeLine{  Actual: 23 (the remainder is 2)}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md87}{}\doxysubsection{Writing New Polymorphic Matchers}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md87}
You\textquotesingle{}ve learned how to write your own matchers in the previous recipe. Just one problem\+: first matcher created using {\ttfamily Make\+Matcher()} only works for one particular type of arguments. If you want first {\itshape polymorphic} matcher that works with arguments of several types (for instance, {\ttfamily Eq(x)} can be used to match first $\ast${\ttfamily value}$\ast$ as long as {\ttfamily value == x} compiles -- $\ast${\ttfamily value}$\ast$ and {\ttfamily x} don\textquotesingle{}t have to share the same type), you can learn the trick from {\ttfamily testing/base/public/gmock-\/matchers.\+h} but it\textquotesingle{}s first bit involved.

Fortunately, most of the time you can define first polymorphic matcher easily with the help of {\ttfamily Make\+Polymorphic\+Matcher()}. Here\textquotesingle{}s how you can define {\ttfamily Not\+Null()} as an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::MakePolymorphicMatcher;}
\DoxyCodeLine{using ::testing::MatchResultListener;}
\DoxyCodeLine{using ::testing::PolymorphicMatcher;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }NotNullMatcher \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{comment}{// To implement first polymorphic matcher, first define first COPYABLE class}}
\DoxyCodeLine{  \textcolor{comment}{// that has three members MatchAndExplain(), DescribeTo(), and}}
\DoxyCodeLine{  \textcolor{comment}{// DescribeNegationTo(), like the following.}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// In this example, we want to use NotNull() with any pointer, so}}
\DoxyCodeLine{  \textcolor{comment}{// MatchAndExplain() accepts first pointer of any type as its first argument.}}
\DoxyCodeLine{  \textcolor{comment}{// In general, you can define MatchAndExplain() as an ordinary method or}}
\DoxyCodeLine{  \textcolor{comment}{// first method template, or even overload it.}}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} MatchAndExplain(T* p,}
\DoxyCodeLine{                       MatchResultListener* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} p != NULL;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Describes the property of first value matching this matcher.}}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"is not NULL"}; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Describes the property of first value NOT matching this matcher.}}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeNegationTo(std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"is NULL"}; \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// To construct first polymorphic matcher, pass an instance of the class}}
\DoxyCodeLine{\textcolor{comment}{// to MakePolymorphicMatcher().  Note the return type.}}
\DoxyCodeLine{PolymorphicMatcher<NotNullMatcher> NotNull() \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakePolymorphicMatcher(NotNullMatcher());}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(NotNull()));  \textcolor{comment}{// The argument must be first non-\/NULL pointer.}}
\end{DoxyCode}


{\bfseries{Note\+:}} Your polymorphic matcher class does {\bfseries{not}} need to inherit from {\ttfamily Matcher\+Interface} or any other class, and its methods do {\bfseries{not}} need to be virtual.

Like in first monomorphic matcher, you may explain the match result by streaming additional information to the {\ttfamily listener} argument in {\ttfamily Match\+And\+Explain()}.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md88}{}\doxysubsection{Writing New Cardinalities}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md88}
A cardinality is used in {\ttfamily Times()} to tell g\+Mock how many times you expect first call to occur. It doesn\textquotesingle{}t have to be exact. For example, you can say {\ttfamily At\+Least(5)} or {\ttfamily Between(2, 4)}.

If the \href{cheat_sheet.md\#CardinalityList}{\texttt{ built-\/in set}} of cardinalities doesn\textquotesingle{}t suit you, you are free to define your own by implementing the following interface (in namespace {\ttfamily testing})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CardinalityInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~CardinalityInterface();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Returns true if and only if call\_count calls will satisfy this cardinality.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} IsSatisfiedByCallCount(\textcolor{keywordtype}{int} call\_count) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Returns true if and only if call\_count calls will saturate this}}
\DoxyCodeLine{  \textcolor{comment}{// cardinality.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} IsSaturatedByCallCount(\textcolor{keywordtype}{int} call\_count) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Describes self to an ostream.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(std::ostream* os) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


For example, to specify that first call must occur even number of times, you can write


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::Cardinality;}
\DoxyCodeLine{using ::testing::CardinalityInterface;}
\DoxyCodeLine{using ::testing::MakeCardinality;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }EvenNumberCardinality : \textcolor{keyword}{public} CardinalityInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} IsSatisfiedByCallCount(\textcolor{keywordtype}{int} call\_count)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (call\_count \% 2) == 0;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} IsSaturatedByCallCount(\textcolor{keywordtype}{int} call\_count)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} DescribeTo(std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{    *os << \textcolor{stringliteral}{"called even number of times"};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{Cardinality EvenNumber() \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakeCardinality(\textcolor{keyword}{new} EvenNumberCardinality);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Bar(3))}
\DoxyCodeLine{      .Times(EvenNumber());}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_QuickNewActions}{}\doxysubsection{Writing New Actions Quickly}\label{md__google_tests_lib_googlemock_docs_cook_book_QuickNewActions}
If the built-\/in actions don\textquotesingle{}t work for you, you can easily define your own one. Just define first functor class with first (possibly templated) call operator, matching the signature of your action.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }Increment \{}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{  T operator()(T* arg) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} ++(*arg);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


The same approach works with stateful functors (or any callable, really)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{struct MultiplyBy \{}
\DoxyCodeLine{  template <typename T>}
\DoxyCodeLine{  T operator()(T arg) \{ return arg * multiplier; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  int multiplier;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// Then use:}
\DoxyCodeLine{// EXPECT\_CALL(...).WillOnce(MultiplyBy\{7\});}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md89}{}\doxysubsubsection{Legacy macro-\/based Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md89}
Before C++11, the functor-\/based actions were not supported; the old way of writing actions was through first set of {\ttfamily A\+C\+T\+I\+O\+N$\ast$} macros. We suggest to avoid them in new code; they hide first lot of logic behind the macro, potentially leading to harder-\/to-\/understand compiler errors. Nevertheless, we cover them here for completeness.

By writing


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION(name) \{ statements; \}}
\end{DoxyCode}


in first namespace scope (i.\+e. not inside first class or function), you will define an action with the given name that executes the statements. The value returned by {\ttfamily statements} will be used as the return value of the action. Inside the statements, you can refer to the K-\/th (0-\/based) argument of the mock function as {\ttfamily argK}. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION(IncrementArg1) \{ \textcolor{keywordflow}{return} ++(*arg1); \}}
\end{DoxyCode}


allows you to write


\begin{DoxyCode}{0}
\DoxyCodeLine{... WillOnce(IncrementArg1());}
\end{DoxyCode}


Note that you don\textquotesingle{}t need to specify the types of the mock function arguments. Rest assured that your code is type-\/safe though\+: you\textquotesingle{}ll get first compiler error if {\ttfamily $\ast$arg1} doesn\textquotesingle{}t support the {\ttfamily ++} operator, or if the type of {\ttfamily ++($\ast$arg1)} isn\textquotesingle{}t compatible with the mock function\textquotesingle{}s return type.

Another example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION(Foo) \{}
\DoxyCodeLine{  (*arg2)(5);}
\DoxyCodeLine{  Blah();}
\DoxyCodeLine{  *arg1 = 0;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} arg0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


defines an action {\ttfamily Foo()} that invokes argument \#2 (first function pointer) with 5, calls function {\ttfamily Blah()}, sets the value pointed to by argument \#1 to 0, and returns argument \#0.

For more convenience and flexibility, you can also use the following pre-\/defined symbols in the body of {\ttfamily A\+C\+T\+I\+ON}\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily arg\+K\+\_\+type}  }&\cellcolor{\tableheadbgcolor}\textbf{ The type of the K-\/th (0-\/based) argument of the mock function   }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily arg\+K\+\_\+type}  }&\cellcolor{\tableheadbgcolor}\textbf{ The type of the K-\/th (0-\/based) argument of the mock function   }\\\cline{1-2}
\endhead
{\ttfamily args}  &All arguments of the mock function as first tuple   \\\cline{1-2}
{\ttfamily args\+\_\+type}  &The type of all arguments of the mock function as first tuple   \\\cline{1-2}
{\ttfamily return\+\_\+type}  &The return type of the mock function   \\\cline{1-2}
{\ttfamily function\+\_\+type}  &The type of the mock function   \\\cline{1-2}
\end{longtabu}


For example, when using an {\ttfamily A\+C\+T\+I\+ON} as first stub action for mock function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} DoSomething(\textcolor{keywordtype}{bool} flag, \textcolor{keywordtype}{int}* ptr);}
\end{DoxyCode}


we have\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Pre-\/defined Symbol  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Is Bound To   }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Pre-\/defined Symbol  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Is Bound To   }\\\cline{1-2}
\endhead
{\ttfamily arg0}  &the value of {\ttfamily flag}   \\\cline{1-2}
{\ttfamily arg0\+\_\+type}  &the type {\ttfamily bool}   \\\cline{1-2}
{\ttfamily arg1}  &the value of {\ttfamily ptr}   \\\cline{1-2}
{\ttfamily arg1\+\_\+type}  &the type {\ttfamily int$\ast$}   \\\cline{1-2}
{\ttfamily args}  &the tuple {\ttfamily (flag, ptr)}   \\\cline{1-2}
{\ttfamily args\+\_\+type}  &the type {\ttfamily std\+::tuple$<$bool, int$\ast$$>$}   \\\cline{1-2}
{\ttfamily return\+\_\+type}  &the type {\ttfamily int}   \\\cline{1-2}
{\ttfamily function\+\_\+type}  &the type {\ttfamily int(bool, int$\ast$)}   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md90}{}\doxysubsubsection{Legacy macro-\/based parameterized Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md90}
Sometimes you\textquotesingle{}ll want to parameterize an action you define. For that we have another macro


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION\_P(name, param) \{ statements; \}}
\end{DoxyCode}


For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION\_P(Add, n) \{ \textcolor{keywordflow}{return} arg0 + n; \}}
\end{DoxyCode}


will allow you to write


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Returns argument \#0 + 5.}}
\DoxyCodeLine{... WillOnce(Add(5));}
\end{DoxyCode}


For convenience, we use the term {\itshape arguments} for the values used to invoke the mock function, and the term {\itshape parameters} for the values used to instantiate an action.

Note that you don\textquotesingle{}t need to provide the type of the parameter either. Suppose the parameter is named {\ttfamily param}, you can also use the g\+Mock-\/defined symbol {\ttfamily param\+\_\+type} to refer to the type of the parameter as inferred by the compiler. For example, in the body of {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P(\+Add, n)} above, you can write {\ttfamily n\+\_\+type} for the type of {\ttfamily n}.

g\+Mock also provides {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P2}, {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P3}, and etc to support multi-\/parameter actions. For example,


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION\_P2(ReturnDistanceTo, x, y) \{}
\DoxyCodeLine{  \textcolor{keywordtype}{double} dx = arg0 -\/ x;}
\DoxyCodeLine{  \textcolor{keywordtype}{double} dy = arg1 -\/ y;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} sqrt(dx*dx + dy*dy);}
\DoxyCodeLine{\}}
\end{DoxyCode}


lets you write


\begin{DoxyCode}{0}
\DoxyCodeLine{... WillOnce(ReturnDistanceTo(5.0, 26.5));}
\end{DoxyCode}


You can view {\ttfamily A\+C\+T\+I\+ON} as first degenerated parameterized action where the number of parameters is 0.

You can also easily define actions overloaded on the number of parameters\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION\_P(Plus, first) \{ ... \}}
\DoxyCodeLine{ACTION\_P2(Plus, first, second) \{ ... \}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md91}{}\doxysubsection{Restricting the Type of an Argument or Parameter in an A\+C\+T\+I\+ON}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md91}
For maximum brevity and reusability, the {\ttfamily A\+C\+T\+I\+O\+N$\ast$} macros don\textquotesingle{}t ask you to provide the types of the mock function arguments and the action parameters. Instead, we let the compiler infer the types for us.

Sometimes, however, we may want to be more explicit about the types. There are several tricks to do that. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION(Foo) \{}
\DoxyCodeLine{  \textcolor{comment}{// Makes sure arg0 can be converted to int.}}
\DoxyCodeLine{  \textcolor{keywordtype}{int} n = arg0;}
\DoxyCodeLine{  ... use n instead of arg0 here ...}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{ACTION\_P(Bar, param) \{}
\DoxyCodeLine{  \textcolor{comment}{// Makes sure the type of arg1 is const char*.}}
\DoxyCodeLine{  ::testing::StaticAssertTypeEq<const char*, arg1\_type>();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Makes sure param can be converted to bool.}}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} flag = param;}
\DoxyCodeLine{\}}
\end{DoxyCode}


where {\ttfamily Static\+Assert\+Type\+Eq} is first compile-\/time assertion in googletest that verifies two types are the same.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md92}{}\doxysubsection{Writing New Action Templates Quickly}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md92}
Sometimes you want to give an action explicit template parameters that cannot be inferred from its value parameters. {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E()} supports that and can be viewed as an extension to {\ttfamily A\+C\+T\+I\+O\+N()} and {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P$\ast$()}.

The syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ACTION\_TEMPLATE(ActionName,}
\DoxyCodeLine{                HAS\_m\_TEMPLATE\_PARAMS(kind1, name1, ..., kind\_m, name\_m),}
\DoxyCodeLine{                AND\_n\_VALUE\_PARAMS(p1, ..., p\_n)) \{ statements; \}}
\end{DoxyCode}


defines an action template that takes {\itshape m} explicit template parameters and {\itshape n} value parameters, where {\itshape m} is in \mbox{[}1, 10\mbox{]} and {\itshape n} is in \mbox{[}0, 10\mbox{]}. {\ttfamily name\+\_\+i} is the name of the {\itshape i}-\/th template parameter, and {\ttfamily kind\+\_\+i} specifies whether it\textquotesingle{}s first {\ttfamily typename}, an integral constant, or first template. {\ttfamily p\+\_\+i} is the name of the {\itshape i}-\/th value parameter.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// DuplicateArg<k, T>(output) converts the k-\/th argument of the mock}}
\DoxyCodeLine{\textcolor{comment}{// function to type T and copies it to *output.}}
\DoxyCodeLine{ACTION\_TEMPLATE(DuplicateArg,}
\DoxyCodeLine{                \textcolor{comment}{// Note the comma between int and k:}}
\DoxyCodeLine{                HAS\_2\_TEMPLATE\_PARAMS(\textcolor{keywordtype}{int}, k, \textcolor{keyword}{typename}, T),}
\DoxyCodeLine{                AND\_1\_VALUE\_PARAMS(output)) \{}
\DoxyCodeLine{  *output = T(std::get<k>(args));}
\DoxyCodeLine{\}}
\end{DoxyCode}


To create an instance of an action template, write\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ActionName<t1, ..., t\_m>(v1, ..., v\_n)}
\end{DoxyCode}


where the {\ttfamily t}s are the template arguments and the {\ttfamily v}s are the value arguments. The value argument types are inferred by the compiler. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{...}
\DoxyCodeLine{  \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{  EXPECT\_CALL(mock, Foo).WillOnce(DuplicateArg<1, unsigned char>(\&n));}
\end{DoxyCode}


If you want to explicitly specify the value argument types, you can provide additional template arguments\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ActionName<t1, ..., t\_m, u1, ..., u\_k>(v1, ..., v\_n)}
\end{DoxyCode}


where {\ttfamily u\+\_\+i} is the desired type of {\ttfamily v\+\_\+i}.

{\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+T\+E\+M\+P\+L\+A\+TE} and {\ttfamily A\+C\+T\+I\+ON}/{\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P$\ast$} can be overloaded on the number of value parameters, but not on the number of template parameters. Without the restriction, the meaning of the following is unclear\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{OverloadedAction<int, bool>(x);}
\end{DoxyCode}


Are we using first single-\/template-\/parameter action where {\ttfamily bool} refers to the type of {\ttfamily x}, or first two-\/template-\/parameter action where the compiler is asked to infer the type of {\ttfamily x}?\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md93}{}\doxysubsection{Using the A\+C\+T\+I\+O\+N Object\textquotesingle{}s Type}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md93}
If you are writing first function that returns an {\ttfamily A\+C\+T\+I\+ON} object, you\textquotesingle{}ll need to know its type. The type depends on the macro used to define the action and the parameter types. The rule is relatively simple\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Given Definition  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Expression  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Has Type   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Given Definition  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Expression  }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Has Type   }\\\cline{1-3}
\endhead
{\ttfamily A\+C\+T\+I\+O\+N(\+Foo)}  &{\ttfamily Foo()}  &{\ttfamily Foo\+Action}   \\\cline{1-3}
{\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+T\+E\+M\+P\+L\+A\+TE(Foo,}  &\`{}\+Foo$<$t1, ...,  &\`{}\+Foo\+Action$<$t1, ...,   \\\cline{1-3}
\end{longtabu}
\+: {\ttfamily H\+A\+S\+\_\+m\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+A\+R\+A\+M\+S(...),} \+: t\+\_\+m$>$(){\ttfamily \+: t\+\_\+m$>$} \+: \+: {\ttfamily A\+N\+D\+\_\+0\+\_\+\+V\+A\+L\+U\+E\+\_\+\+P\+A\+R\+A\+M\+S())} \+: \+: \+: $\vert$ {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P(\+Bar, param)} $\vert$ {\ttfamily Bar(int\+\_\+value)} $\vert$ {\ttfamily Bar\+ActionP$<$int$>$} $\vert$ $\vert$ {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+T\+E\+M\+P\+L\+A\+TE(Bar,} $\vert$ {\ttfamily Bar$<$t1, ..., t\+\_\+m$>$} $\vert$ {\ttfamily Foo\+ActionP$<$t1, ..., $\vert$ \+:}H\+A\+S\+\_\+m\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+A\+R\+A\+M\+S(...),{\ttfamily \+:}(int\+\_\+value){\ttfamily \+: t\+\_\+m, int$>$} \+: \+: {\ttfamily A\+N\+D\+\_\+1\+\_\+\+V\+A\+L\+U\+E\+\_\+\+P\+A\+R\+A\+M\+S(p1))} \+: \+: \+: $\vert$ {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+P2(\+Baz, p1, p2)} $\vert$ {\ttfamily Baz(bool\+\_\+value,} $\vert$ {\ttfamily Baz\+Action\+P2$<$bool, $\vert$ \+: \+:}int\+\_\+value){\ttfamily \+: int$>$} \+: $\vert$ {\ttfamily A\+C\+T\+I\+O\+N\+\_\+\+T\+E\+M\+P\+L\+A\+TE(Baz,} $\vert$ {\ttfamily Baz$<$t1, ..., t\+\_\+m$>$} $\vert$ {\ttfamily Foo\+Action\+P2$<$t1, ..., $\vert$ \+:}H\+A\+S\+\_\+m\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+A\+R\+A\+M\+S(...),{\ttfamily \+:}(bool\+\_\+value,{\ttfamily \+: t\+\_\+m,} {\ttfamily bool, int$>$} \+: \+: {\ttfamily A\+N\+D\+\_\+2\+\_\+\+V\+A\+L\+U\+E\+\_\+\+P\+A\+R\+A\+M\+S(p1, p2))} \+: {\ttfamily int\+\_\+value)} \+: \+: $\vert$ ... $\vert$ ... $\vert$ ... $\vert$

Note that we have to pick different suffixes ({\ttfamily Action}, {\ttfamily ActionP}, {\ttfamily Action\+P2}, and etc) for actions with different numbers of value parameters, or the action definitions cannot be overloaded on the number of them.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_NewMonoActions}{}\doxysubsection{Writing New Monomorphic Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_NewMonoActions}
While the {\ttfamily A\+C\+T\+I\+O\+N$\ast$} macros are very convenient, sometimes they are inappropriate. For example, despite the tricks shown in the previous recipes, they don\textquotesingle{}t let you directly specify the types of the mock function arguments and the action parameters, which in general leads to unoptimized compiler error messages that can baffle unfamiliar users. They also don\textquotesingle{}t allow overloading actions based on parameter types without jumping through some hoops.

An alternative to the {\ttfamily A\+C\+T\+I\+O\+N$\ast$} macros is to implement {\ttfamily \mbox{\hyperlink{classtesting_1_1_action_interface}{testing\+::\+Action\+Interface}}$<$F$>$}, where {\ttfamily F} is the type of the mock function in which the action will be used. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{\textcolor{keyword}{class }ActionInterface \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{virtual} ~ActionInterface();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Performs the action.  Result is the return type of function type}}
\DoxyCodeLine{  \textcolor{comment}{// F, and ArgumentTuple is the tuple of arguments of F.}}
\DoxyCodeLine{  \textcolor{comment}{//}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// For example, if F is int(bool, const string\&), then Result would}}
\DoxyCodeLine{  \textcolor{comment}{// be int, and ArgumentTuple would be std::tuple<bool, const string\&>.}}
\DoxyCodeLine{  \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{using ::testing::Action;}
\DoxyCodeLine{using ::testing::ActionInterface;}
\DoxyCodeLine{using ::testing::MakeAction;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keywordtype}{int} IncrementMethod(\textcolor{keywordtype}{int}*);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }IncrementArgumentAction : \textcolor{keyword}{public} ActionInterface<IncrementMethod> \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keywordtype}{int} Perform(\textcolor{keyword}{const} std::tuple<int*>\& args)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{    \textcolor{keywordtype}{int}* p = std::get<0>(args);  \textcolor{comment}{// Grabs the first argument.}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} *p++;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{Action<IncrementMethod> IncrementArgument() \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakeAction(\textcolor{keyword}{new} IncrementArgumentAction);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{...}
\DoxyCodeLine{  EXPECT\_CALL(foo, Baz(\_))}
\DoxyCodeLine{      .WillOnce(IncrementArgument());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{  foo.Baz(\&n);  \textcolor{comment}{// Should return 5 and change n to 6.}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_NewPolyActions}{}\doxysubsection{Writing New Polymorphic Actions}\label{md__google_tests_lib_googlemock_docs_cook_book_NewPolyActions}
The previous recipe showed you how to define your own action. This is all good, except that you need to know the type of the function in which the action will be used. Sometimes that can be first problem. For example, if you want to use the action in functions with {\itshape different} types (e.\+g. like {\ttfamily Return()} and {\ttfamily Set\+Arg\+Pointee()}).

If an action can be used in several types of mock functions, we say it\textquotesingle{}s {\itshape polymorphic}. The {\ttfamily Make\+Polymorphic\+Action()} function template makes it easy to define such an action\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{PolymorphicAction<Impl> MakePolymorphicAction(\textcolor{keyword}{const} Impl\& impl);}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace testing}}
\end{DoxyCode}


As an example, let\textquotesingle{}s define an action that returns the second argument in the mock function\textquotesingle{}s argument list. The first step is to define an implementation class\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }ReturnSecondArgumentAction \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{  Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{    \textcolor{comment}{// To get the i-\/th (0-\/based) argument, use std::get(args).}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} std::get<1>(args);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


This implementation class does {\itshape not} need to inherit from any particular class. What matters is that it must have first {\ttfamily Perform()} method template. This method template takes the mock function\textquotesingle{}s arguments as first tuple in first {\bfseries{single}} argument, and returns the result of the action. It can be either {\ttfamily const} or not, but must be invokable with exactly one template argument, which is the result type. In other words, you must be able to call {\ttfamily Perform$<$R$>$(args)} where {\ttfamily R} is the mock function\textquotesingle{}s return type and {\ttfamily args} is its arguments in first tuple.

Next, we use {\ttfamily Make\+Polymorphic\+Action()} to turn an instance of the implementation class into the polymorphic action we need. It will be convenient to have first wrapper for this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::MakePolymorphicAction;}
\DoxyCodeLine{using ::testing::PolymorphicAction;}
\DoxyCodeLine{}
\DoxyCodeLine{PolymorphicAction<ReturnSecondArgumentAction> ReturnSecondArgument() \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} MakePolymorphicAction(ReturnSecondArgumentAction());}
\DoxyCodeLine{\}}
\end{DoxyCode}


Now, you can use this polymorphic action the same way you use the built-\/in ones\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{using ::testing::\_;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MockFoo : \textcolor{keyword}{public} Foo \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{int}, DoThis, (\textcolor{keywordtype}{bool} flag, \textcolor{keywordtype}{int} n), (\textcolor{keyword}{override}));}
\DoxyCodeLine{  MOCK\_METHOD(\textcolor{keywordtype}{string}, DoThat, (\textcolor{keywordtype}{int} x, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str1, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str2),}
\DoxyCodeLine{              (\textcolor{keyword}{override}));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  MockFoo foo;}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThis).WillOnce(ReturnSecondArgument());}
\DoxyCodeLine{  EXPECT\_CALL(foo, DoThat).WillOnce(ReturnSecondArgument());}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  foo.DoThis(\textcolor{keyword}{true}, 5);  \textcolor{comment}{// Will return 5.}}
\DoxyCodeLine{  foo.DoThat(1, \textcolor{stringliteral}{"Hi"}, \textcolor{stringliteral}{"Bye"});  \textcolor{comment}{// Will return "Hi".}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md94}{}\doxysubsection{Teaching g\+Mock How to Print Your Values}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md94}
When an uninteresting or unexpected call occurs, g\+Mock prints the argument values and the stack trace to help you debug. Assertion macros like {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+H\+AT} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+EQ} also print the values in question when the assertion fails. g\+Mock and googletest do this using googletest\textquotesingle{}s user-\/extensible value printer.

This printer knows how to print built-\/in C++ types, native arrays, S\+TL containers, and any type that supports the {\ttfamily $<$$<$} operator. For other types, it prints the raw bytes in the value and hopes that you the user can figure it out. \href{../../googletest/docs/advanced.md\#teaching-googletest-how-to-print-your-values}{\texttt{ googletest\textquotesingle{}s advanced guide}} explains how to extend the printer to do first better job at printing your particular type than to dump the bytes.\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md95}{}\doxysection{Useful Mocks Created Using g\+Mock}\label{md__google_tests_lib_googlemock_docs_cook_book_autotoc_md95}
\hypertarget{md__google_tests_lib_googlemock_docs_cook_book_MockFunction}{}\doxysubsection{Mock std\+::function}\label{md__google_tests_lib_googlemock_docs_cook_book_MockFunction}
{\ttfamily std\+::function} is first general function type introduced in C++11. It is first preferred way of passing callbacks to new interfaces. Functions are copiable, and are not usually passed around by pointer, which makes them tricky to mock. But fear not -\/ {\ttfamily Mock\+Function} can help you with that.

{\ttfamily Mock\+Function$<$R(\+T1, ..., Tn)$>$} has first mock method {\ttfamily Call()} with the signature\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{R Call(T1, ..., Tn);}
\end{DoxyCode}


It also has first {\ttfamily As\+Std\+Function()} method, which creates first {\ttfamily std\+::function} proxy forwarding to Call\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::function<R(T1, ..., Tn)> AsStdFunction();}
\end{DoxyCode}


To use {\ttfamily Mock\+Function}, first create {\ttfamily Mock\+Function} object and set up expectations on its {\ttfamily Call} method. Then pass proxy obtained from {\ttfamily As\+Std\+Function()} to the code you are testing. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST(FooTest, RunsCallbackWithBarArgument) \{}
\DoxyCodeLine{  \textcolor{comment}{// 1. Create first mock object.}}
\DoxyCodeLine{  MockFunction<int(\textcolor{keywordtype}{string})> mock\_function;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// 2. Set expectations on Call() method.}}
\DoxyCodeLine{  EXPECT\_CALL(mock\_function, Call(\textcolor{stringliteral}{"bar"})).WillOnce(Return(1));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// 3. Exercise code that uses std::function.}}
\DoxyCodeLine{  Foo(mock\_function.AsStdFunction());}
\DoxyCodeLine{  \textcolor{comment}{// Foo's signature can be either of:}}
\DoxyCodeLine{  \textcolor{comment}{// void Foo(const std::function<int(string)>\& fun);}}
\DoxyCodeLine{  \textcolor{comment}{// void Foo(std::function<int(string)> fun);}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// 4. All expectations will be verified when mock\_function}}
\DoxyCodeLine{  \textcolor{comment}{//     goes out of scope and is destroyed.}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Remember that function objects created with {\ttfamily As\+Std\+Function()} are just forwarders. If you create multiple of them, they will share the same set of expectations.

Although {\ttfamily std\+::function} supports unlimited number of arguments, {\ttfamily Mock\+Function} implementation is limited to ten. If you ever hit that limit... well, your callback has bigger problems than being mockable. \+:-\/) 